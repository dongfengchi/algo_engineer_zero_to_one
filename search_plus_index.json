{"./":{"url":"./","title":"算法工程师从零到一","summary":"作者峰池和这本书，算法工程师从零到一","keywords":"","body":"算法工程师从零到一 我是峰池，是一名推荐算法工程师，目前就职于字节跳动。 这本书：《算法工程师从零到一》，就是自己一个新的尝试。我希望能够把自己对这个行业和这个岗位的一些想法和认知系统的输出出来，给那些互联网有兴趣的同学们系统的一些参考。 希望这本书能够帮助那些对互联网有兴趣的，想成为算法工程师的同学们。 我是一名非科班出身的码农，本科学的是工商管理。16年考研时才开始接触代码，全靠自学。硕士读的是应用统计，和机器学习算法稍微沾点边。18年硕士毕业，校招加入字节跳动做推荐算法工程师，刚入职的时候经历了非常长且痛苦的适应时间。主要的点在于自己在学校里面学到的知识，与真实的工业应用场景之间存在着巨大鸿沟：好像实际在工业场景应用的重点，和自己在学校学习的要点，有太多对不上的了。 于是在自己适应之后，就一直在想自己能不能做一点什么事情，可以帮助那些在校的同学们更好的了解这个行业，让他们知道现在工作需要什么样的技能和人才，让后来的同学可以少走那些自己之前趟过的坑。 所以我开通了自己的微信公众号：峰池(fengchitalk)，一直在尝试做这个方面的努力。因为工作的原因，其实更新的次数并没有特别的多，但是依然有后来的师弟师妹们跟我反馈说，我的这些内容对他们职业道路选择起到了一定的帮助，有一部分同学甚至完全是按照我划定的方案制定的自己的计划，最后成为一名互联网人，成为一名算法工程师。 自己在看到这些消息的时候，感到非常高兴的同时，也希望自己能够写下更多的内容，来帮助更多的同学们。同时希望这些东西可以更加系统一些，帮助到更多的人。 所以我把自己公众号上的内容整理总结了一下，并重写了其中一些段落，集结成了这本书。希望能够帮助你从一名校园萌新，成长为一名算法工程师。 目前自己粗略的统计应该字数是五万有余，看到这个结果自己还是挺开心的。当然字数只是一方面，如果真的对大家有所帮助那就是太开心了。 可以我提供了PDF和网页端两种形式 网页端大家可以直接访问https://dongfengchi.github.io/algo_engineer_zero_to_one/ pdf大家可以添加我的微信fengchi_dong或者在公众号后台回复从零到一获得。 当然，囿于自己自身能力上的局限，书中肯定有一些不完美的地方，比如一些技术性的错误、一些观点上的偏差甚至还有一些排版上愚蠢的地方。还望大家可以多多指出，峰池在这里不尽感激。 此外，我所在的团队负责常年招收算法工程师，校招社招实习均可。我们是字节跳动GIP推荐算法，包括今日头条、西瓜视频、番茄小说等其他App的推荐算法工作。欢迎同学们直接加我个人微信fengchi_dong进行内推。想了解也行，包行业背景介绍，简历辅导，意志不坚定灌鸡汤，面试准备方案制定等等一条龙服务。没有做不到，只有想不到！ 如果对我个人感兴趣，或者对内容有疑问，可以通过以下两种方式找到我~ 微信公众号：峰池(fengchitalk) 知乎：@峰池 微信公众号： 作者: 峰池，一个爱读书的算法工程师            最近更新： 2021-03-09 06:44:53 "},"chap01/1-internet_industry_trend.html":{"url":"chap01/1-internet_industry_trend.html","title":"1-1 互联网整体发展趋势","keywords":"","body":"1-1 互联网整体发展趋势 整体互联网行业趋势 当前整体的互联网行业，虽说“内卷”这个词喊的越来越响，各种996、007等等迷之代号层出不穷，代表着着竞争压力在日渐增大。但不可否认的是，整体互联网行业依然是一个处在发展和上升期的行业。 行业处在上升期，这也就意味着机会和职业发展短期之内是看好的。表现为两点： 需要招聘的岗位数在不断的扩大。 如果能够在上升期尽可能早的加入这个行业，成为从业者，可能得到的锻炼和经验技能上的提升。可能会帮助你加速你的职业生涯职位和薪水方面的提升。 关于第二点，对大部分同学来说，可能无法决定自己的毕业年份。但是对于那些自身已经非常优秀，在纠结是否在学历上更上一层楼(比如读硕士/读博士/读博士后)的同学们来说，可能可以在做决定的时候再斟酌一下。 当然大家对互联网行业也不能盲目乐观：这个行业也是一个风险非常大的行业。具体表现为： 应用场景在不断变化升级：比如在很长一段时间内，微信被认为已经终结了社交这场战争。但是最近短视频行业的发展，让微信不得不下场迎战，加码了很多之前因为“小而美”而没有上线的功能，这是一种变；比如社区买菜，大家可能之前都没有发现这个市场，但是就在一段时间内突然爆火。而这个应用场景和之前的大部分应用场景都不太一样，那么这个场景的经验也就需要从业人员从零开始学习思考积累了。 技术在不断的升级：而且技术的升级通常会产品形态的跳变，这会在很短时间的内革掉之前从业者的命。比如生产最好的磁带的人你现在已经找不到了、生产最好的台式电脑的人已经江河日下了、可以发送最好的彩信功能的公司也已经不在了、现在也再也见不到非触摸屏的手机了，这样的例子我们可以举出很多，甚至当年《基业长青》的书中精心挑选的长青公司，现在有一多半也已经死掉了。每一个例子背后的其实都有盛极一时的成功经验和产品模式，而这样的经验在新技术来临的时候，就会变得不值一提。 行业整体的升级和演化速度非常的快速，各种创业公司小公司层出不穷，经常会有一些爆款的应用或者游戏就是出自一些之前完全没有听过的小公司手中。甚至那些我们之前认为的行业巨头，在新的时代也面临着巨大的挑战。 所以选择了互联网行业，也基本意味着选择了不断应对技术与挑战和终生学习。 这不是一个你吃老本就可以活得很滋润的行业，而是一个每天都要应付新需求新挑战的行业。自己的心态一定要调整好。 应付挑战和不断努力，和其他行业比，其中要付出的艰辛自然也会更多一些。 作者: 峰池，一个爱读书的算法工程师            最近更新： 2021-03-09 06:44:53 "},"chap01/position_description.html":{"url":"chap01/position_description.html","title":"1-2 互联网中的主要岗位都是在干些啥？","keywords":"","body":"1-2 互联网中的主要岗位都是在干些啥？ 在有了行业背景之后，我们来简单聊聊互联网公司内都有哪些职位，看看他们日常的分工是怎么样的，以及如何支撑起一个互联网公司运转的。 产品经理 产品经理是决定产品方向的人。一个好的产品会清楚自己的产品的痛点是什么。包括目前产品的现状，应该往哪个方向发现，在一步步实现产品的诸多功能的过程中主要的优先级是什么。坊间有句话叫做：产品是CEO的摇篮，其实就是产品这个岗位重要性的体现。 具体到工作上，我个人认为产品经理最重要的是定义需求。其中最重要的来源是同理心，就是把自己想象成用户的样子去使用自己的功能，看看有哪些不爽点，就是需要优化和改进的地方。在定义需求的过程中，可能需要依赖具体的业务数据和指标的拆解分析，以及调研分析市场上现有的类似产品的功能，查漏补缺。在想清楚了具体的需求之后，需要写作具体的需求文档，不断的与研发等各个上下游进行沟通，确定具体的实现方案，然后排定优先级，规划完成时间等等，目标是要把需求完成，并且最好可以证明自己的需求是有价值的。 俗话说口说无凭，有时候为了可以更加准确客观的表达清楚自己的意思，就需要制作出产品的原型图来更加准确的表达自己功能的真实意图，以及最终呈现的效果。而在制作原型图的过程中，不可避免的又会涉及到用户的交互和设计，这是两个比较核心的产品支持部门。我们用的产品，其外观和交互大部分都来自于产品团队和设计团队不断思考与碰撞得出的。 产品在制定好产品方案之后，俗称需求文档，会拿着这份文档去找研发对接具体的实现。一般会在文档里面附上自己与设计师们沟通好的原型图。一个好的需求文档，就是一份好的施工图纸，里面明确的说明了产品功能的预期和逻辑，研发们只需要关注具体的技术实现。沟通能力和项目管理的能力是在我看来产品最核心的能力。 在我看来，产品的潜在弊端在于，单靠的产品功能逻辑本身，是支撑不起一个合格的App的。比如我有一个像素级抄袭抖音的App，有可能取得抖音的效果吗？答案很可能是否定的。产品功能可以帮一个App搭起架子，但内容的承接还是要靠运营。 运营 在产品开发完成上线之后，有用户进来开始使用了，为了给他们以更好的使用体验，就会有一群人专门想方设法想让他们在产品上玩起来。怎么可以让用户在自己的产品上使用的满意，参与度高，这就是我眼中运营工作的最主要任务。比如在设计和组织某一个活动来促进发文，或者号召和推广用户参与某一个具体的话题，比如“冰桶挑战”，抑或者是设计出游戏的春节活动，刺进用户进行购买。运营是距离用户最近的人，他们在和用户一起探索产品的具体用法，帮助更多的用户更加深入的了解产品。 一个好的运营，会清楚的知道自己的用户需要什么，他们通过自己的聪明才智，拉进产品本身和用户之间的距离。比如常见的有负责策划活动和接受用户反馈的用户运营，负责具体某一个具体内容垂类保证作者可以持续不断的发文的垂类运营(各种热点在站内的发酵通常都有运营同学的参与)等等。 运营是产品某种角度上的“推广员”，相当于是在熟悉产品既有游戏规则的情况下，把这些规则和玩法通过活动的形式让更多的用户参与进来，知晓其中玩法；或者和用户一起制定和推广由少部分新潮用户发起的新兴玩法。 运营和产品很多时候是密不可分的。一个App发展的不同阶段，在前期可能产品功能迭代比较多，在后期产品形态比较稳定之后，功能上的大改通常比较少了，这时候就更加依赖运营。很多时候，运营是业务的发起方。比如现在有一个大型的活动(比如新年集卡)需要产品功能的支持，这时候就需要产品配合一起把这个功能完善做好。 在我看来，运营潜在的弊端在于，他们策划的活动或者项目通常不太方便进行线上ab测试，所以就非常依赖运营自身的经验和聪明才智。而在算法大行其道的背景下，运营自身的经验判断，可能和算法的数据结果可能会有冲突。这个时候，解决争端的方式可能就和公司的价值观有关：是更加信任算法的结果呢？还是应该更加信任运营在行业内的经验呢？ 研发工程师 研发：笼统的说，就是一群写代码的，是产品最主要的沟通对象。他们把具体的产品需求，从一个个需求文档一张张效果图变成真正意义上的产品功能。一般而言，研发是对写代码的统称。具体到现在常见的移动互联网公司中，通常又包括以下几个大类： 客户端工程师。目前市面上比较流行按照操作系统分成Android和iOS，这两个系统实现语言和代码框架完全不同。相应的，核心编码的语言是Java和Swift。在我眼中，客户端工程师和前端工程师有些类似，就是把后端给予的信息，按照产品的要求呈现在用户的面前，是和用户直接交互的一环。客户端工程师和算法工程师，尤其是推荐算法工程师，关联最紧密的一部分是：客户端记录了大部分的用户行为，所有的用户行为统计都是从客户端这里产出的。而这些其实也是推荐算法最重要的目标。 后端工程师，又称服务端工程师。后端工程师是系统背后的英雄，他们是软件功能可以正常使用的幕后英雄。除了客户端具体的展示逻辑之外，双端(Android和iOS)公共的业务逻辑都是在这里一并产出的。包括但不限于：如何能够在大量并发的用户请求下还能保证这个系统稳定不宕机、怎么优化前端请求相应的延时、怎么样存储大量的用户数据、如何进行容灾等等。因为Go在高并发场景下的卓越性能，现在Go已经成为后端工程师的重要语言；此外常见的语言还有Java。在系统刚开始搭建的时候可能还会有Python，但在大型软件中Python的动态类型的特性会变成其重大的劣势：比如你在写自己负责的代码模块时，永远都不知道你的上游究竟会给你这个模块传进来一个什么变量，就可能出现一些非常奇怪的代码报错。 算法工程师。算法工程师是伴随着机器学习兴起的一个岗位，严格意义上来说，它应该属于后端工程师的一种，因为算法本质上是一种算法优化之后的结果。和后端工程师主要的不同点在于，后端对请求的响应一般情况下是规则定义的，意味着结果是确定的；而算法对请求的响应是通过模型预估的，可能一个请求的返回结果做模型的人事先自己也说不上来。 这三大工程师，是现在主流的互联网公司的主要研发力量。在我看来，在产品规模较小的时候，算法工程师的重要性没有那么大，可能人工制定一些规则就可以足够支撑初期阶段。在产品逐渐壮大的过程中，再伺机抽象出算法模块，进行迭代和优化。 客户端和后端是一个App的基础，而算法一个App最终效果的放大器。 数据分析师 数据在现代商业活动中愈发重要，数据分析师就是在这样的大浪潮下火起来的一个岗位。一名优秀的数据分析师会对产品各个维度的数据都了如指掌，因为基本上所有的产品运营依赖的数据都是从数据分析师这里产出的。 他们知道它需要的数据从哪里来：要给客户端研发提需求，让他们从在客户端记录下来用户行为，这是最原始的用户行为数据。 他们更加合理的整理他们的数据：通过hive等工具建立合理的数据仓库，为业务方使用更加方便的使用数据打下基础； 他们知道他们的数据最后在哪里产生价值：他们会对产品运营活动产出一份份数据分析报告，分析产品功能是否符合预期；制作数据监控，对产品是否在正确的轨道上运转给出最准确的数据度量。 一般而言，数据分析师是产品运营的左膀右臂，产品运营对数据拿不准有需求拿不准的时候都会来求助数据分析师。数据分析师最常接触的数据是一张张hive数据表，他们通常写SQL查数取数，通过一些可视化工具比如tableau制作报表，在分析产品决策的过程中，他们会通常使用统计方法，主要是显著性的分析来判断实验结论是否显著。 在数据分析师有一定的数量之后，会有一些通用的支持的工作被抽出来做数据分析师的支持。主要包括： 数据仓库研发：他们是专门抽出来做一些复杂数据表的建设的，比如一些重要的数据表，被很多下游数据表依赖，数仓研发同学就会把这些数据表过去，优化产出和时延，保证可以在规定的时间产出。 实验分析中台：很多策略上线之前都会进行ab实验，而ab实验分析的结果是否显著是很多数据分析师的公共任务。这一部分任务会被中台同学维护起来，包括但不限于提出好用的实验分析方法，实验显著性分析的工具等。 可视化组件维护团队：比如负责维护可视化组件比如tableau后台等。 用户增长(User Growth) 这是近十年来新兴的一个岗位，做增长黑客。这个团队主要的目的是拉动产品的用户规模。比如拉高新增用户数量，提升用户粘性和活跃度，确保用户留存等。为了提高业务的核心指标，理论上他们可以通过设计、产品、研发策略等多个手段达成目的。 比如为了提升新增用户的数量，我们应该使用什么样的方式，在哪里投放什么样的广告 比如为了提升新用户的体验，我们应该怎么样给那些新来的用户一个最好的产品体验 这些都是UG团队日常需要思考的问题。 为了解决这两个问题，他们会有自己的产品团队涉及合适的新用户的体验、专门的算法团队负责广告素材的制作以及可能的投放，以期最大化新用户的量级。 其他一些岗位 战略：公司要往什么方向进行发展？公司在市场上的位置怎样？下一步应该往哪个方向发展呢？这是战略需要解决的最核心问题。他们比具体的产品思考的纬度更高一层，可以理解为公司自己的一个咨询部门。相应的，他们的做事方法和套路和咨询也比较相似，相对也比较偏好咨询背景的同学。 人力：人力实际上是平时日常生活中接触最多的一种公司职能部门，实际上也是我的老本行(笑)。通常情况下，接触比较多的是人力岗位是HRBP，他们的主要任务是负责组内的招聘，薪酬和绩效管理。一般比如内推同学都找他们，他们平常会安排好组内需要约见面试、绩效管理等等。此外还有专门负责校园招聘、人才培训、户籍档案管理、以及全公司范围内薪酬体系建设的专职同学。后面这些同学一般接触的比较少，但是在需要的时候，他们会用自己最为专业的知识为我们解决最急需的问题。一般在正式入职之前，大家打交道最多的，应该就是人力的同学。 还有诸如财务、行政等等的部门，这部分工作的职能应该都比较清楚，我这里就不多做解释了。 作者: 峰池，一个爱读书的算法工程师            最近更新： 2021-03-09 06:44:53 "},"chap01/3-work_experience.html":{"url":"chap01/3-work_experience.html","title":"1-3 工作体验","keywords":"","body":"1-3 工作体验 主要分成以下这几个部分：工作环境、工作的日常节奏以及简单说说新人体验。 工作环境 现在主流的互联网公司，工作环境比较类似的，关键词是舒适。因为程序员从事的是创造性的劳动，需要一个舒适的环境才能最大的激发他们的生产力。而公司一般也会把这种舒适的环境，作为吸引人才的重要宣传素材。 体现为几个方面： 一、生产设备。现在主流的互联网公司，公司会给新入职的同学们配备新款设备，比如在字节跳动，对于大部分技术同学来说，公司会配置新款的macbook pro，原因主要是系统稳定以及编程环境容易配置。这个电脑基本相当于是公司发给你的，自己想怎么玩都可以。三年期满还可以再换新的。同时，公司同时也会配备额外外接的显示器，这样可以多个屏幕办公，提升工作和代码开发的效率。 二、餐饮。大部分主流的互联网公司，都会有自己的食堂，员工的三餐，都可以在公司内部解决。伙食的质量都是很不错的，字节跳动的餐标据说是100/天。即使是那些没有食堂的公司，大部分公司也会提供餐补，给员工在外就餐提供一些补贴。此外，很多公司还有免费发放的零食、下午茶、咖啡等等，基本可以保证吃饱喝足，热量拉满。经常可以在电梯里等等一些公共场合听到一些自己完全不认识的同学，说道自己又胖了五斤。于是减肥成为很多同学的常驻目标。 三、其他福利。常见有，免费的健身房，满足对健身的日常需求；就近租房补贴：如果你租住的地方离公司很近，可能每个月要给你1500元的补助；日常也发一些文化衫或者玩偶以及生活用品；晚上加班回家打车可以公司报销；公司内部举行的一些文体活动，比如羽毛球赛等等；还有日常公司帮忙组织的一些日常必需的福利，比如例行的体检，商业保险等等，带薪的年假和病假等等。 总之基本上公司可以帮助你对日常生活的需求，你的衣食住行都多多少少可以帮助你解决。公司对你的预期只有一件事：你能安安心心的把本职工作做好。 在我看来，这些福利确实可以让公司里面的工作的同学感受到：公司确实是在为你着想，生活在其中可以感受到一定的幸福感。同时这些宣传通常会让家里的老人长辈感到非常的开心：他们通常会很担心衣食住行的问题。但我对这些东西的观感是，这些可以成为你选择一份工作的加分项，但不是唯一的理由：相对来说，做出有价值的事情才是更应该考虑的。 日常节奏 互联网公司现在成为“加班”奋斗的代名词，大家被996 007各种代号搞得晕头转向，可能还有一些担心害怕的的心态。那么一个日常的算法工程师的日常节奏是怎么样的呢？我以我个人的经历来简单聊聊。 为了讲清楚日常工作的节奏，前提条件是讲清楚我们日常在干什么。节奏就是，我们怎么安排自己的时间，去做这些日常的工作。 作为一个算法工程师，我们的日常工作主要包括以下这几个部分： 模型相关的迭代：这个既包括模型结构的迭代，也包括特征的迭代。这个可能是大部分同学对算法工程师的认知：算法工程师自然都是训练模型的。但实际上，可能模型结构实际上迭代的并不多。更多的模型工作发生在，新的场景需要模型(比如上了新的app或者支持新的活动)，或者新的用户行为(比如点赞、评论)需要模型来预估，一些新的模型特征加入到模型里面等等。 推荐策略的迭代：因为推荐算法工程师，实际上也算是半个内容生态相关的产品；我们通常会根据产品的要求，做一些推荐策略的迭代。典型的迭代场景是，如果我们不对推荐系统做任何干预的话，大概率推荐出来的结果都会是一些比较偏低俗的东西(这是人类的本性)，所以我们就需要对推荐系统做一些干预，这些干预通常会以损失推荐系统的效果来换取：因为这意味着不能推点击率最高的候选，只能推满足要求的候选。 ab实验。在互联网公司，大家对在线的策略，一般都是怀有敬畏之心的。理论上线上所有的变更，都必须做ab实验，在取得明确的效果和结论之后之后，才可以上线。所以这个过程中涉及ab策略的代码开发，以及策略的实际结果的分析，通常涉及一些数据分析以及一些简单的统计中的假设检验。 整体上，公司内部的氛围是有比较强的空间和自主权，有实现自己想法的机会和空间。例如：你看到了一篇好的论文，觉得可能对当前的场景有帮助，那就可以自己尝试一下；比如你觉得当前的这个场景，有一个重要的特征目前还没有考虑到，那就可以跟产品和运营去聊，获取相应的支持。这一点可以说是非常开放的。 日常的工作节奏也相对来说比较轻松，没有那么刻板，体现在： 每天十点上班，但可能大部分同学都是十点半左右才到 晚上一般意义上是七点下班，但大部分同学是九十点左右离开 如果偶尔有事，要提前走，一般在群里说一声就行，也不需要特别注意什么 整体上，算法工程师日常的工作还是比较规律的，我常常觉得这个和读书的时候在读书馆其实没啥本质区别。可能偶尔会有一些特别紧急的项目需要赶，可能需要加班到十一二点。但绝大多数情况下，还是比较稳定的。 公司对你的要求就是，能干完活就行，其他的你可以任意安排。干完活的表现就是，每周会定期有一个周会，大家会讲一下自己这一周都干了一些啥，你只要能在这个会上能讲出有工作量的内容，就是达标的。 前段时间看的《奈飞文化手册》，里面有一点印象很深刻：现在大公司想招聘的员工，都是成年人。怎么定义成年人呢？可能每家公司定义都不太一样，但是基础的就是：不需要再像小孩子一样时时监督着你，让你打卡定义量表，而是相信你可以在基本的诉求得到满足的情况下，做持续稳定的输出。这一点在互联网公司就体现的非常淋漓尽致。 新人体验 上面聊到了一些工作的日常和工作节奏，大家其实可以看出来，其实整体的氛围还是相对比较宽松，且有一定的自主权的。那么新人入职的时候感觉怎么样呢？ 坦率的说，如果新人想要加入，还是有一定的门槛的。这个门槛主要表现为代码的问题，以及工程实现瓶颈。我们分开来说。 代码的难度。在聊代码难度之前，我们其实讲的不是编程语言基础语法的难度，而是随着代码量的提升带来的复杂度的增加。这很容易会让没有大型代码经验的同学摸不着头脑。须知，几百行的代码和几万行的代码，其实是两个不同难度系数的东西。大型项目的组织背后通常涉及到一些设计的基本思路(通常意味着大量的业务背景)和代码组织的一些规范和方式(比如设计模式)，无论是哪一种，都意味着大量的名词堆砌，这意味着短时间内要接触到大量的概念，这个一般需要时间，很难快速消化。一般来说，一个新人加入我们组，通常第一个月很难有效的产出。 工程实现瓶颈。当我们离线搞一个算法项目的时候，我们通常可以搞的非常的简单，搞一个训练集和测试集，随便写一些模型训练代码就可以了。但是，当一个模型在生产环境下在线部署的时候，背后的基础设施架构其实是面临着很多约束。这就会导致我们在离线训练模型用pandas随便搞一搞的事情，在在线环境下可能就会变得遥不可及，需要比较多的工程开发。比如怎样科学的部署一个强化学习的系统，其实相对就比较复杂，需要大量的工程开发。 不过这种客观的难度其实也意味着门槛。因为通常来说，对你来说难的东西，对其他人也通常意味着难度。而门槛通常也意味着，你一旦跨越过去之后，就可以帮助你拦下很多其他的竞争对手。所以大家不要因为难而却步。 我反而由衷的建议大家，在面临人生的选择的时候，如果在各方面都其他偏好都一致的情况下，尽可能选择那些难一点的道路。迈过眼前的难关之后，可能就是一片通途。 具体的新人应该如何适应算法工程师的职场，我之前的一篇文章其实讲了比较多，感兴趣的同学可以参考 作者: 峰池，一个爱读书的算法工程师            最近更新： 2021-03-09 06:44:53 "},"chap01/2-the_way_grown_up.html":{"url":"chap01/2-the_way_grown_up.html","title":"1-4 晋升路径&回报","keywords":"","body":"1-4 晋升路径&回报 算法工程师行业发展 算法工程师是近十几年因为机器学习技术突破而火起来的一个岗位，在这一轮互联网整体行业的发展中起到了非常重要的作用。 和整体互联网行业的大部分岗位一样，算法工程师当前也是在不断的招人。最开始的扩招是因为技术的突破，大家都纷纷意识到了这一块的重大价值。但近几年，技术本身其实没有出现巨大的突破。相反，深度学习技术本身可能已经进入了一个平台期：虽然总有一些技术进步的新闻出现，但可能在主要的应用场景，取得颠覆性的技术突破已经比较难了——现在算法模型本身已经很难取得排除机器资源增加之外带来的单纯的模型收益。 算法工程师当前扩张的原因，主要还是在于应用领域的扩展。比如今日头条在刚刚出现的时候，还能以人工智能推荐系统千人千面作为宣传的噱头，但是今天市面上以及很少有内容类的App没有推荐系统了：这意味着每家互联网公司都有了自己的算法团队。此外，现在的机会点也在于，把之前一些不能用机器学习解决的问题，变成或者尝试用机器学习来解决。比如内容领域的审核，之前可能每一篇文章都是要人来判断这个文章是否违规，但现在可能算法可能可以帮助我们把那些有明显不良信号的内容直接自动识别出来干掉，只让人来判断那些模型判断不好的内容。 有一个最直接的证据可以佐证这个行业的发展趋势：那就是薪水。毕竟价格是由供需关系决定的。以及大家都是打工人，其实也最关注薪水的变化。 自18年以来，校招硕士，算法工程师同一个岗位同一个标准下的工资差不多是(只是我自己了解的一个岗位，不代表任何公司或者统计意义上的平均值)： 22k(18年) ==> 23k(19年) ==> 25k(20年) 18年之前，因为我确实没有关注，好像比较少听到校招生的薪水能够上20k。这个趋势也侧面反映了，这个行业当前对人才的需求状况。 不可否认是，因为价格的大幅上涨，新进入这个行业的同学的数量也在提升。所以这也意味大家面临的竞争也日趋激烈。所以在找工作的时候就要做好准备，这个我们后面再聊。 岗位发展前景晋升路径 大家在学校期间比较关心的一个点就是，我的职业发展到底是一个什么样？我干多久能到一个什么样的程度？ 这个信息其实是一个大伙都好奇，但是确实不太容易获得到的消息。可能大家在校期间，在校招的时刻，还会比较彼此的offer，谁在哪里拿了多少钱都一清二楚。但是一旦进入职场，公司的薪酬可能就不是一个大家都能开诚布公拿出来聊的事情了。比如大家都干同样的活，如果你知道你的薪水比同桌的大哥低很多，那很可能就接受不了，工作不愉快，生产力低下，被老板谈话了。 当然这一点和企业文化也是有关的，有些是公司的职级和薪水不公开的，有些是职级公开，但是薪水不公开，有一些极端的公司是全部公开(据说netflix是这样)。 但是呢，有人的地方就会有江湖，有江湖的地方就会有数据。知乎上有一个大V，@曾加，他根据脉脉职言区用户公开上传的offer数据整理了一下大概的offer情况，以及一般情况下多长时间能到达什么样的级别。我这里截取出来一些重要信息，大家可以以这个作为参考。感兴趣的大家也可以点文末的阅读原文直接看知乎的原文。 一般而言，现在职场上大家对标的，一般都是阿里的级别体系(我也不知道为啥)作为参考，以「硕士毕业校招」为职业起点，平均来讲： P5 对应工作 0～2 年，大部分人会在参加工作后 1～4 年内升到下一级别； P6 对应工作 2～5 年，大部分人会在参加工作后 3～8 年内升到下一级别。 P7 对应工作 5～8 年 ==> 这个级别一般传说叫做大头兵。就是负责一个小的方向，手下带两三个同学一起开发 P8 对应工作 8～12 年 ==> 这个级别基本上就是小组leader了。 关于各级别的薪资大家可以参考这张图： 来源：最新！互联网大厂各职级薪资对应关系图（2020 年 5 月） - 知乎 具体的职业能力要求方面，在P5/P6这个阶段，基础能力，尤其是代码能力是最重要的。在P7及以上，还要提升自己对业务的理解能力。大家在社招换工作的时候也可以多多考虑一下。 方向选择 这里想跟大家多说一点，就是大家不要被眼前的offer薪水所迷惑。大家在选择offer的时候，看重钱是一方面，毕竟大家都是打工人，work for money并没有什么错。但是还是要思考一下自己所在的行业和将来可能应用的空间有多大。 举个例子：内容推荐算法目前来说可能是一个比较好的岗位，因为之前提到了，各家公司现在都有内容推荐的算法工作。同理，广告变现也是一个比较好的岗位，也是因为广告变现对于任何一家公司来说都是非常重要的。所以相对来说，在算法的细分行业中，这两个解决具体问题的算法可能相对来说，将来的空间相对来说会更大一点。 还有一些算法，本身也很重要，但可能应用的领域没有那么广泛。这时候最好建议大家还是多思考一下。比如互联网金融，算法本身很重要，但是随着监管愈发严格，可能也只有蚂蚁金服或者微信有比较大的体量支撑得起大规模的金融算法，其他的可能会受限于数据规模或者技术投入等等，可能能学习到的技术是比较有限的；同理还有路线规划算法，业务场景本身很重要，但是应用的领域可能本身比较有限，这种场景大家在进入之前就可以多考虑一下。但不排除将来自动驾驶或者物联网大热，所有的物品运输都需要更复杂的路线规划算法，所以大家可以有一些自己的判断。 作者: 峰池，一个爱读书的算法工程师            最近更新： 2021-03-09 06:44:53 "},"chap01/4-other_questions.html":{"url":"chap01/4-other_questions.html","title":"1-5 其他问题：城市、户口&实习","keywords":"","body":"1-5 其他问题：城市、户口&实习 我这里选择了一些同学们日常会向我提问的一些问题。 城市选择 想从事互联网可以选择的城市是比较少的，基本上只有一些大型城市，比如北京、深圳、杭州、上海这几个地方。因为在二线城市，或者没有互联网基础的城市中，很难找到足够的互联网人才，互联网公司很难发展起来。 而在大城市中做选择，不如说是在众多大型互联网公司中做选择。因为除了北京当前叫得出名字的互联网公司多一点，剩下的比如提起深圳就离不了腾讯；提起杭州很大程度上和阿里、网易有关；而提起上海目前比较响亮的有拼多多、B站。虽然现在有一些公司比如像字节跳动全中国有很多研发中心，但是可能相对来说当你的业务和部门确定了之后，基本也就确定了工作地点。 所以基本上，当选择确定了公司之后，工作地点和城市就确定了下来。 而选择公司，本质上是一个选择行业、赛道以及企业文化相关的综合性的问题，这个大家应该都能有所耳闻，就不在这里单独聊了。 在自己面临多个城市不知道该怎么选择的时候，我建议大家一、考虑另一半的职业发展和城市选择；二、选择整体互联网氛围更浓厚的城市，比如北京；这样将来想跳槽的时候，更加方便找下家。工作成家之后再举家搬迁，可能相对来说不是一个那么容易决定的事情。 而对于选择城市的担忧，主要有两点，一点是房价，一点是户口。 首先聊聊房价。大家在面临城市选择选择的时候，可能会被所在地的房价吓到，觉得压力太大无力偿还。我个人的看法是，如果你的能力足够进入头部互联网公司，那么房价对你来说应该问题不大。房价问题只是时间问题。而且房价问题属于厚积薄发急不来的事情，如果觉得自己未来还需要奋斗一把搏一搏，不要被这种十年之后的问题妨碍了自己当前的选择，就如同我们现在不考虑死亡之后的事情一样。 其次是户口，大部分同学对城市的担忧本质上是对于户口的担忧，所以我把户口单独拆出来聊一聊。 户口 算法工程师属于互联网行业，这个行业目前是不太容易拿到户口的，这样很多同学纠结不已。在北京这一点掣肘更甚，因为深圳和上海当前的户口政策还可以靠积分，但是北京基本只有毕业这一次户口获得机会。有一些同学为此深深苦恼。 户口整体的大原则是，能拿尽量拿，但要注意控制损失。有几个途径： 一、稳健型。如果自己在毕业的时候，有稳定的男女朋友，可以进行分工，一人去比如一个肯定有户口的地方比如大多数的银行和事业单位，一人走互联网(工资高)。这样大家整体收入和户口都可以得到保障。还有一种分工方式是，在不确定将来要去哪座城市发展的时候，可以一人拿一个城市的户口，比如北京、深圳。这样可以把未来的选择权那在自己手中。 二、毕业一年先拿户口，然后跳槽。比如先去某一个研究所、或者小公司拿到户口，然后一段时间之后，再支付xx万的违约金跳槽。这种操作我个人不是特别建议。有几点原因，一、时间预期。很多公司口头上承诺是一年后帮忙落户，但是因为落户的流程整体比较冗长，等真正户口到手，可能需要的时间就要接近两年了。二、成长速率受损。毕业前几年是个人成长最快，培养工作习惯最关键的几年。而这些有户口指标的研究所或者国企，大部分情况下整体的工作氛围和人员质量是不如一线互联网大厂的。俗话说，由俭入奢易，由奢返简难，你那里培养的一些工作习惯和一些对世界的观点态度，很可能会让你在这个高速发展的世界中丧失竞争力。 三、互联网自身有户口。这是大部分互联网人梦寐以求的。但大多数互联网公司的套路都是：在招聘时候不承诺，只是说有可能，给你一点希望，可能最终是你的，也可能最终不是你的。这种把人吊住的感觉是很不好的，而且通常被吊住了之后，也很大可能拿不到。对于那些志在必得的同学来说，很可能最终是竹篮打水一场空。 互联网公司的户口多多少少也会有一些惩罚机制：比如3年离职12万这种。意味着如果你拿到户口之后3年内离职，都要赔偿公司一笔户口的补偿金。这也是公司为了拴住自己的一些优秀人才的一种方式。所以户口基本上是对那些优秀的人才才会给。 我这里聊几个可能会对在毕业时候直接拿到户口有帮助的点。大家要明白的一点是，户口是公司奖励给那些同龄人中足够优秀的同学们的，所以要尽量努力成为同一级中那些优秀的同学。 有分量的论文。这个就不说了，体现你在学校期间能力的时候到了。且这个论文最好和岗位需要的论文匹配。比如你是研究推荐系统的，发了顶刊的论文，这个论文对于做推荐来说分量就很重，对于做CV的可能就帮助不大。 实习。尤其是长时间的实习，对拿户口是很有帮助的。我想提的一点是，很多同学总有各种各样的理由不愿意提早去实习，常见的理由是论文以及自己没有准备好。这是个人的选择没有错，但是很多同学不太清楚提早实习的潜在收益是什么。我能看得到的收益有两点：一、提早积累工作经验，对尽早晋升是有帮助，而这通常意味着加薪(较大幅度)；二、如果你能在实习期间有高质量的工作成果，得到大家的认可，那么户口会是很大概率的。即使他们的offer中是可能有户口，那这个可能性真正落到你头上就会变得很大。我身边就有两个同学，拿着字节普通的算法offer，但是因为大家对他们实习期间工作能力的肯定，在非预期的情况下拿到了户口。此外，长时间的实习，如果最终留用，大概率是有户口的(实习时间长了，其实有些问题都是可以和老板聊的)。 异地户口。对于那些在异地有办公场所的公司，比如字节、腾讯、阿里，这些公司其实都是可能有异地户口能力的公司，意思是你人在北京上班，但是有可能公司帮助你在深圳落户。但是具体公司的政策是不一样的，还有一些是半保密状态，所以大家可能要多和HR沟通，探探政策和口风。 实习选择 如果只有一次实习的机会，尽量选择大厂，大厂是实习的硬通货。就如同在学生时代，大家可能会更加认可北大清华的学生一样；在工作时代，大家更加认可的是在大厂的工作经验和经历。 如果开始规划的时间比较早，可以有机会多份实习。那我也建议大家多看看，感受一下不同公司的不同岗位的工作氛围，选择一份自己更加喜欢的行业和职业发展方向。毕竟很多时候，再多人的经验贴都是都是耳听为虚眼见为实。 但是我不建议大家为了刷工作经历的数量，强行说比如每过三四个月就换一份实习，如果上一份实习不想做了，我个人觉得唯一的合适的更换实习的理由就是自己不想做了，可以是不适应现在的工作节奏、不喜欢现在的组、或者觉得自己在当前的实习岗位上已经没有额外的学习的空间了。 如果觉得自己实习所在的组不错，氛围和做的事情都是自己喜欢的，是可以一直实习的。一直实习有诸多好处，比如工作经验潜在户口等等，我上文也已经列举过了。 注意一点是，实习的时候心态要调整好，不要自己觉得仅仅只是一个实习生，就对自己放低要求，或者只做一些基础的工作。要用一个正式员工的心态来要求自己，积极参与组内的一些事项。比如参加组会了解其他同学在干嘛，以及思考业务现在面临的问题，提出一些自己对当前问题的看法等等。 没有人愿意带一个对自己要求放低的“实习生”，大家愿意指导的是那些经验欠缺的“成年人”。 最后来一则招聘广告，我所在的团队常年招收算法工程师，校招社招实习均可。我们是字节跳动GIP推荐算法，包括今日头条、西瓜视频、番茄小说等其他App的推荐算法工作。欢迎同学们直接加我私人微信fengchi_dong进行内推。想了解也行，包行业背景介绍，简历辅导，意志不坚定灌鸡汤，面试准备方案制定等等一条龙服务。没有做不到，只有想不到！ 作者: 峰池，一个爱读书的算法工程师            最近更新： 2021-03-09 06:44:53 "},"chap02/1-preparing.html":{"url":"chap02/1-preparing.html","title":"2-1 求职准备","keywords":"","body":"2-1 求职准备 再开始找工作之前，我们先聊聊求职的准备工作。求职准备，包括一些诸如求职信息，招聘流程等等的工作。 但在这诸多准备工作之中，其中最重要一点是想法和心态的转变。只有心态上做好准备了，剩下的所有准备工作才是扎实而有效的。 这一点尤其重要。我见过太多的“好学生”，学习能力很强，聪明程度也够，自身也很优秀。但因为想法和心态上相对“保守”，不够“开放”，自己把自己的路走窄了。 我们来分三个点来聊： 成长是自己的事情 开放心态 不要给自己设限 成长是自己的事情 成长是自己的事情，我个人很喜欢这句话。这句话是我入职字节之后，内部一个很高级别的技术负责人给我们做分享的时候提到的。现在也想把这句话转送给大家。 这句话怎么理解呢？ 可能在学校的同学们已经习惯了在老师或者学校给定的赛道里面努力：有一个优秀的期末考试成绩，在学生组织里面担任关键角色，做一个好的社会实践。在学校里面，这些都没问题，甚至可以成为奖学金的加分项。但问题是，这个赛道的成绩，并不一定是下一个阶段需要的。 我知道很多同学因为种种原因对互联网很感兴趣，想成为一名算法工程师或者其他互联网中的一员。但是他们面临的一个问题就是：这个岗位的很多要求，在学校里面并没有学到。比如对于想做算法的同学，算法岗要求代码能力。但是他们发现自己并没有上过代码相关的课程。于是自己就蒙了，不知道接下来要怎么做。甚至还有很多同学，只是因为觉得这个概念很酷，就想参与，而没有自己了解搜索过。 有一个很残酷的事实想告诉大家的是，互联网行业因为信息技能迭代的速度过快，导致具体的应用所需要的技能，与实际学校里面教授的知识之间的差距，是在不断扩大的。那中间的这个gap要怎么弥补呢？仅仅靠自己在学校的那些“应得”的知识是远远不够的，是需要自己在这个过程中不断的探索和努力的。成长是自己的事情，所有的路都是自己走出来的。 比如想提高自己的代码能力，那就去看一些代码相关的经典教材；如果看书觉得累了，就在网上搜一些可以实操的脚本；再不济可以自己去打竞赛，逛github等等。这些我只能告诉你可能会有所帮助，但可能不会有人拍胸脯告诉你，你做了这些事情，就一定可以成为一个合格的算法工程师。 相对来说，自己选择的道路确实是充满了不确定性，因为没有人会告诉你，做了这件事是不是真的就可以得到回报。比如自己学了python一个月，是不是就是可以真的找到一个算法的实习；比如自己看完了《统计学习方法》是不是机器学习算法能力就能烂熟于心；比如自己好不容易找到的一份实习是不是一个可以真正让自己学习提高的地方。没有，也不会有人给你这样的承诺。还是需要大家靠自己去趟出那条属于自己的道路。 可能大家在学校已经习惯：做了某件事情就可以有好的结果。比如付出了努力上课学习，就可以得到好的成绩。但是未来走出校园，你会愈加发现，有太多太多的事情，努力只是其中最简单的一环。可能很多时候最开始的方向就找错了，这时候努力也只能是得到一个不能取得效果的结果。知难行易，就是这个道理。 之前有很多同学问我说：峰池你能不能告诉我具体我应该怎么提高我的代码能力？他们想要的是一条可以照着做就能实现的路径。但抱歉我真的不知道，因为这些东西是你应该自己去选择一条最适合自己的道路。如果世上真的有捷径，那么走的人一定会特别多，那么这条路也就会慢慢变得人满为患，而不再成为捷径。 我只能在一些方向性的问题上，给大家一些我自己的看法，让大家做一些参考。这也是我现在这本小册子，最努力想要达到的样子。 成长是自己的事情，选择好自己要做什么是自己的事情。可能刚开始真的很不适应，因为以前我们可能只需要学习好，剩下的似乎都是顺水推舟，没有什么选择的事情。走向职场应该是我们要面临的第一次选择，肯定有不适应与不安，但我们能做的，也只能是努力选择一条适合自己的道路，然后加油。加油！ 摆正心态 还有一个我经常被问的问题是：峰池，你能不能看看我的简历，看看我适合什么样的工作？ 这些同学有时候真的非常优秀，他们觉得自己什么都可以做，只是不知道该做哪个方向而已。 但是正如我上面一点说的，成长是自己的事情。你应该做的是，摆正自己的心态，想清楚自己到底想要做什么。相应的，问题就应该变成，我想做xxx，你看看能不能帮帮我？ 还有一点是，要明白评价体系的改变。在学校的时候，同学之间的评价体系大多都是你当了什么班级干部，你做了什么社会实践。 但是一旦求职，我们就要习惯以求职者的评价体系来审视自己。比如一个算法工程师，对人的要求就是代码能力要过硬，这时候即使你在原有评价体系里面那些加分项比如班级干部社会实践，可能都会成为没有用的东西。 换位思考，从求职者的角度出发思考一下某一个岗位需要什么样的人才，然后自己尝试去匹配它，这也是一种摆正心态。 不要给自己设限 不要给自己设限。这也是我非常喜欢的一句话，在这里送给大家。 不要给自己设限，意味着不要觉得自己是非计算机科班出身的同学，就做不了算法工程师。 不要给自己设限，意味着不要觉得自己是一名算法工程师，就只能在技术的领域深挖。 不要给自己设限，意味着不要觉得自己做不了什么，任何技能理论上都是可以后天习得的，只要你想，你愿意投入时间和精力。 我觉得，大家都是二十多岁的年轻人，没有什么东西是自己不能做的。只是大家因为环境或者历史选择等等的原因，没有往这个方向去考虑，没有投入相应的时间精力。 保持着对生活的好奇心，探索这个世界自己未曾探索的领域，去亲自参与这个时代的伟大变革，创造历史给后人看看，这种感觉不是更好吗？ 本篇其实略显鸡汤，但是确实是一段时间跟学弟学妹们交流之后的内心真实感想。很多同学是内心有想法，但是真的不知道应该怎么去做，能力相应的反而变成很次要的事情了。希望这篇鸡汤能够给内心有这个疑问的同学们一点内心上的支持吧~大家都是趟坑过来的。 还是那句话，你觉得困难的事情大家都会觉得困难，越过它了之后你就可以甩开那些被这个困难吓倒的人了。所以，大家加油~ 作者: 峰池，一个爱读书的算法工程师            最近更新： 2021-03-09 06:44:53 "},"chap02/2-process.html":{"url":"chap02/2-process.html","title":"2-2 整体流程","keywords":"","body":"2-2 整体流程 互联网招聘大的流程分成两种，一种是大规模的校园招聘，一种是直接到组的招聘。大规模的校园招聘是全公司走统一的流程，一般是面向大规模的校招生，进行大规模面试，参加校园面试之前也不知道自己将来会到哪个岗位上去。另一种是直接到定向到岗位的招聘，就是你应聘就是为了成为这个岗位这个组的一员。各种内推，实习都是走的这条路子。两条路径一般互相不冲突，大家是可以两种都参与的。 相对来说，校园招聘的流程更长的一点，笔试面试都有，中间的时间间隔(等待时间)也会更长。定向到岗的招聘一般只有面试，等待的时间也会更短一点。所以大家也可以看出来，相对笔试来说，面试其实是更加重要的，更应该好好准备的一个环节。 我们先以大规模的校招串一下整体的流程，然后再聊聊定向到岗的面试。也就是我们常常说的内推。 校园招聘 互联网的大规模校招分为按时间早晚排序分为秋招和春招两个阶段，横跨整个毕业季度一整年。我们来按照时间顺序先后来详说。 相对于其他行业而言，互联网的秋招开始的很早。互联网巨头大公司在七八月份就已经开始了大规模的校招宣传(事实上可能三月份就开始了，也就是暑期实习，我后文会提到)。作为对比，各大银行在10月中旬才会放出当年的招聘岗位和指标。 一般开始宣传，就意味着可以按照宣传中的方式投递简历了。 投递简历有几个平台，比如51job，大街网等等。这些平台的好处在于，你在这些平台上编辑好了自己的简历信息之后，直接点公司投就行了，即一份简历，多次投递。但是更多情况下，大一点的互联网公司，公司都会给你一个自己的官方网站，让你自己重新再填写一份简历，即一份简历，一次投递。好在技术类的岗位一般情况下没有诸如“你做过最困难的事情是什么？”“你最大的优点和缺点各是什么？”这样的哲学问题。这一过程是很劳神的，如果遇到比较坑爹的情况，自己填了半天网页弹出保存失败请重试，那是真的想拍桌子的。建议大家在进行这一步的时候，找一个txt或者word文件，无格式的保存简历项目，方便复制粘贴。如果你现在不懂我在说什么，没关系，你会懂的。 在简历投递完成之后，可能会过一次简单的简历初筛，然后就要开始大规模的笔试了。 笔试 笔试一般出现在大规模招聘活动中，比如校招(包括秋招和即将开始的春招)和暑期实习招聘，目的是为了简单快速的筛选一部分候选人。方式是在开始之前一天左右丢给你一个线上的网址，你在指定的时间访问这个网址，输入自己的ID，就可以参加在线答题了。线下的笔试现在已经很少了。较少的互联网公司会有性格测试，大部分都是客观测试为主。 在线答题一般情况下是两小时，题型主要是选择题和编程题。选择题海纳百川，从排列组合和数据结构，到操作系统和智力题，以及一些我也不知道他在考啥的问题。总之尽自己所能作答，能蒙就蒙。考核的重心是在编程题。一般情况下，两个小时的在线答题会有三道左右的编程题。通常是你根据题目要求写一段程序后提交，后台会有几个测试用例，看指定的输入会不会在你这里跑出符合题目要求的输出，根据通过测试用例的比例来计分。时间通常比较紧张如果不熟悉这个流程，推荐大家提前熟悉考试平台，推荐牛客网，其他大同小异。大家这一块需要好好刷题准备，你再优秀过不了笔试那是全白搭。 笔试通过之后，过一段时间就会收到面试通知。一段时间可以是第二天，也可以是一个月。大多数情况下，即使你没有通过笔试，公司也不会给你通知，所以你在等待的面试通知可能真的就不存在。所以自己心里要对自己的笔试成绩有客观合理的认识。包括面试，也很少有公司正式发拒信的。如果笔试或面试不理想，及时调整心态，再投一个。多说一句，笔试是不讲情面的，能过就是过，过不了可能就直接被刷了。考题以计算机专业的人认为的“基础知识”为主，所以是有一定难度的。所以笔试大家一定认真准备。 不过可以告诉大家一个好消息：如果有师兄师姐的内推，有时候是可以绕过笔试的，这就省很多心力了。所以大家一定要多种途径打听内推的消息。当然，如果大家想来字节跳动，可以直接找我，微信峰池(fengchi_dong)进行内推，各种职位都可以。 面试 面试才是正式的考核。校招的面试通常有三面，日常的实习一般是两面，当然这也视情况而定。 面试就是考试，考核的方式主要是代码题，辅以一些机器学习算法的问题。考核范围在面试准备一节有详细说明，此处不再赘言。 代码题的考核方式可能对从未参加过的人来说比较特别：面试官会给你一张白纸，告诉你一道题，比如写一下快速排序。需要你在白纸上把快速排序写出来，一般情况下你可以自己选择最熟悉的代码语言来写这道题。对于没有练过白纸写代码的同学，一定要自己练一下，白纸写代码和在有色彩高亮和代码补全的IDE中写是有很大不同的。白纸写完之后，面试官会针对你的代码提一些问题，一般是看你的代码对一些边界用例能否通过。所以在把你的代码交给面试官之前，自己可以先检查一下代码的边界问题。 代码非常重要。代码题的考核，直接决定了你这次面试的最终结果。大家一定要注意，以及多加练习。 机器学习算法在面试中的考核主要是围绕你的简历展开的，一般会让你详述简历中的算法相关项目。你解决的是什么问题，如何构造特征，用了什么算法，这个算法的一些细节问题，最后模型的效果怎样等等。接下来面试官可能会针对你的回答适当的做一些拓展。所以大家一定要对简历中提及的东西足够熟悉。 要啰嗦的一点是：在面试之前首先摆正心态。不要抱怨这件事为什么代码是重要的。要知道即便是算法工程师的身份进去，无论校招也好实习也罢，都是要从最基本的代码开始做的，可能前两个月都不一定能摸得到模型。所以会写代码，会干活肯定是主要的考核点。以及在谈话时要注意，招你进来是为了干活的，不是让你来指导他们的。所以面试的问题回答不要太意识流，理想主义。知道得多是好事，但是过于显摆而显得不太踏实那就是另外一回事了。表现为，写代码时清清楚楚，不要眼高手低；回答问题时，清晰而有条理的说出自己对这个问题的看法，不要刻意往自己觉得熟悉的地方引。 此外，对于一个算法工程师而言，其基础是先成为一个工程师。所以面试基础是代码能力，相对来说，机器学习能力其实是加分项。 一般而言，现在的互联网公司的面试都比较人性化，多轮面试会排在同一天进行。一般最后面都会是HR。如果你的面试没有见到HR就被送走了，那多半是被淘汰了。及时总结这次面试中自己遇到的问题，再接再厉。 互联网行业的大规模笔试面试一般会在10月底结束。作为对比，银行通常11月才开始笔试。如果面试通过被公司录取，一般会距离面试结束一周左右的时间，会有HR电话通知并与你商谈offer，主要是薪资和入职实习的时间。同意接offer后还有些手续，按照HR指示的流程来走就行。从十一月开始会陆陆续续出现一些公司补录，这是一个机会。如果在秋季没有找到心仪的工作，也可以再等等春招的机会。春招一般2月中旬开始宣传，三月份开始笔试面试。整体互联网公司大的统一的招聘流程就是这样。 内推 内推在整体互联网招聘中是非常非常重要的一环。我建议大家是，如果有资源内推，尽量走内推。比如你可以找我，加我微信：峰池(fengchi_dong)就行。 内推有以下几个好处： 整个招聘进度流程的监控。很多时候，招聘流程会被卡在某一个地方，或者参加完了面试很久没有通知结果，作为参加招聘的同学自身是没法知道的，这时候直接找HR问一般回应也会比较官方。但是如果是内推的话，内推的同学是可以帮忙追踪到当前流程的，并且可以在公司内部找人问的。这样自己心里就会更加踏实一点 内推很多时候是可以跳过笔试，直接进入面试阶段的。 就面试难度而言，内推和普通面试的难度其实并没有区别。 暑期实习与日常实习 暑期实习一般开始于每年的三月份，注意留意各大公司的招聘网站，以及各种学长学姐的消息。 暑期实习后一般都有秋招直接留用的机会。比如互联网巨头，一般进去暑期实习没有什么大的问题都会选择留用的，因为对于技术类的岗位，往往熟悉整个流程可能就要花去一个月左右的时间，所以一般公司也不会希望自己的实习生离开，所以我前面说巨头的秋招三月份就已经开始了。且因为暑期留用的比例高，秋招时的招人指标会大比例的被这些留用的实习生占据，到时候在校生再想通过秋招进去就难了。 此外，暑期实习的面试难度是低于秋招的。所以暑期实习这个机会一定要把握和珍惜。多注意信息的搜集。多说一句，有的大公司，比如阿里腾讯，一般是不招聘日常实习生的，所以暑期实习基本上是获得这两个公司实习的唯一机会，要珍惜。 多说一句暑期实习和日常实习的区别。最开始的暑期实习，可能公司还会做一些精细的准备，比如单独给他们配备mentor，专门暑期实习的同学设计一个项目，指导他们完成。但现在暑期实习更像是一种有“品牌感”的日常实习生。所以作为在校想实习的同学们，可以没必要专门为了等暑期实习而实习，早实习早积累经验。毕竟真正来实习了之后，你会发现，日常实习和暑期实习其实没啥区别。 作者: 峰池，一个爱读书的算法工程师            最近更新： 2021-03-09 06:44:53 "},"chap02/3-resume.html":{"url":"chap02/3-resume.html","title":"2-3 简历制作","keywords":"","body":"2-3 简历制作 今天我们来重新聊一下简历的制作。主要是分成一下两点： 简历的目标 简历制作的思路 简历的目标 简历的目标只有一个：需要让大家通过看这个东西，能了解你是一个什么样的人，有什么样的能力，以及是否适合当前的这份工作。本质上说，简历是就是一个文字版本的自我介绍。 我们要做的事情就是，通过内容的编排和布局，在规定的篇幅里面，达到让看到你这份简历的人，觉得你非常优秀，非常适合这份工作。 这里面有几个常见的问题： 篇幅。篇幅最好是一页纸，如果你的经历非常的优秀，那也要尽量精简和筛选到一页纸以内。注意，不是把你的所有的经历全部罗列上去就好，是要根据岗位做筛选和优先级排列的。下文我们会讲具体的思路。 重点。在一页纸的简历中，是有主次关系的。你可以想象一下自己手拿一页A4纸的时候，觉得最重点的区域在哪里？是不是一定在中部靠上的地方？所以简历的中上部分一定要放自己最重点想放的东西。把你觉得自己最惊艳的东西放在这里。然后再在下面顺次堆叠那些次重要的部分。 基本信息。有几个最基本的信息是一定需要的：姓名、毕业时间、学校、专业、联系方式。除了这些之外，照片、民族、主修课程和成绩这种，你可以根据你求职面试的岗位酌情添加。怎么酌情呢，就出想想如果你真的面试这个岗位，你想想你会不会介绍这些信息。然后省出来的空间，可以多放重点信息。 不要在你的简历里面预设问题。自己的小算盘是：我这里藏一个梗，面试官在面试的时候可能会看到就这个梗提问，然后自己就可以流畅作答。不要打这种小聪明。对于那些别人需要一些上下文才能知道，那就说清楚上下文。简明清晰的说清楚，否则别人会觉得你表达有问题。 简历栏目内的时间序是倒序，即最近发生的事情是在最上面的。这是一个约定俗成的规定。 简历制作的思路 接下来我们来重点聊聊简历制作的思路，这个思路决定我们怎么填充简历的内容，以及怎么定不同项目之间的优先级。 要声明的一点是：简历不是经历的堆积，是需要开动脑筋的回顾个人历史总结之后的一个输出。大家的简历，很少有一次成型的，都是要经过不断修改打磨的。所以，一个好的简历的制作的预期时长，可能比你预想的堆满一页A4纸需要的时间要更长一点。不要想着草草了事，是要花时间认真对待的。 简历制作的整体思路是：我们必须知道岗位的需求是什么。然后在这个目标的指引下，填充自己的工作经历。与目标有关的，就多写，越相关越重点，越重点越放前面；与目标无关的，就少写或者不写。这个过程中一定要有自己的判断和取舍。 然后每一段经历，要展开写的详细一点。展开要求直击你做的这件事的核心，用准确且不拖沓的语言描述清楚你做这件事情的原委以及其中的关键点，用以证明你对这件事情到底了解到什么程度。这时候是要见自己功底的时候，一定要把故事说清楚，讲圆了，不要半途而废。 我们来看几个常见的优化点： 一、应聘算法工程师，需求是代码能力和机器学习算法能力。如果写了很多学生活动，社会实践，社会调研，这属于无关的；如果写了市场部的实习生，这属于无关的；如果写了数据分析实习生，因为分析师强调的能力是数据分析，技能项其实与算法工程师的技能有偏，这属于弱相关的。 二、项目经历。常见的问题是，只写了一句话，别人不知道这个项目是在干啥。比如简单一句话，我用pandas分析了数据，这个是什么意思呢，有什么结果呢？一定要写清楚写明白。项目背景，项目遇到的问题是什么，你用了什么方法解决的，解决的效果怎么样。这一串问题都希望能够在简历中看到答案。可以用一种方式检验一下：给周围的同学讲一下，看他们是不是能明白你的这个任务的产出。 三、想明白岗位的需求。不同的岗位需要的能力是不一样的，相应的，如果自己想做多个选择，制作多份简历也是必要的。 四、如果自己一些项目经历欠缺怎么办？如果自己思前想后，发现自己实在是欠缺某一项能力怎么办？我建议最好还是在学校的期间恶补一下，比如打比赛或者先做一份小的实习；或者通过自己的自学能力的成果证明自己确实是具备相应的能力：比如网上的一些小的练手的项目，研究一下，包装一下，也是可以成为自己的项目经历的。项目经历的补充，还是主要依靠大家在学校期间，同学们之间相互交流和借鉴。需要声明的一点是，论文只是众多项目中的一种，如果你能拿得出其他比论文更厉害的项目经历，证明自己的能力，加分是不输于论文的。(比如自己实现了某一个开源库)。所以不要过于看重论文，论文只是证明自己能力的一种方式而已。 所以一切的出发点，都是要先明白一个工作岗位的要求。那么怎么样可以得到这个信息呢，我个人总结了三个途径： 最不依靠人的：就是去网站上搜这个岗位的职位要求，根据这个职位要求去拓展去匹配。问题是这个职位要求通常其实也是HR写的，他们其实并不太懂具体某一个岗位到底在做些啥。为了不出错，他们就会看看其他人对这个职位要求该怎么写。所以造成的结果就是市面上搜到的职位要求实际上都差不多。可能会和具体的岗位要求不怎么匹配。 人脉广型：多问问认识的人，最好是认识心仪的组里的同学或者师兄师姐，他们最熟悉组里需要什么东西以及该在么准备，说不定还能帮你透点题。 自己更生型：多参加面试。一是面试多了自己心里就会有点谱；二是面试结束后一般面试官都会问一句你有什么其他问题么？抓住这个机会可以向面试官请教一二，比如应该准备些啥，该如何准备，这些其实都可以问问他们。毕竟这本质上也是一个闻道有先后的问题，如果你诚心去问，一般都不会对你恶语相向的。 其实归根到底，简历锻炼的是自己信息组织和归纳的能力。这种能力在工作中也是非常重要的。所以，其实在你的简历交到面试官手上的时候，其实对你的能力考核，就已经开始了。大家千万不要掉以轻心哦~ 现在如果有新同学想帮忙内推的时候，我基本上看一眼他的简历，就知道他通过的概率有多大了。大家一方面要重视自己的简历编排；另一方面也要借着简历制作的过程，重新梳理一下自己当前的状态和能力，是不是适合自己想要的工作，然后及时的做好查漏补缺，为正式的面试和下一步的人生做好准备。 从这个角度来说，简历其实也是一个很好的三省吾身的工具。 作者: 峰池，一个爱读书的算法工程师            最近更新： 2021-03-09 06:44:53 "},"chap02/4-interview.html":{"url":"chap02/4-interview.html","title":"2-4 面试准备","keywords":"","body":"2-4 面试准备 广义上的算法岗又可以细分为机器学习、深度学习、自然语言处理、图像处理等岗位。其中自然语言处理和图像处理这两个岗位有比较强的专业特性，一般需要你在学校时就接触相应的项目实践，或者之前就做过相应的实习，否则很难申请到这两个岗位的工作。所以我们这里的讨论就只针对一般意义上的算法工程师。 要注意的一点是，算法工程师，首先是一个工程师，其次才是算法工程师。这就意味着，面试考核的标准首先是工程师的，就是计算机和代码能力，其次才是机器学习算法。有太多同学忽视了这一点，面试跪于代码题，最终没有取得自己理想的offer。 算法岗要求总览 在互联网公司的职位表中，这个算法工程师又有几个别名：数据挖掘工程师，数据算法工程师。或者根据具体的方向又分为：广告算法工程师，推荐算法工程师等等，本质上考察的东西都差不多。我大致整理了一下，主要有以下几个方面： 计算机能力 程序设计：代码题。主要是基本的代码使用能力，主要是代码逻辑符合预期，不出现代码bug，以及会分析和优化代码效率。 算法能力 传统机器学习算法：逻辑回归(考的最多)，SVM，树及其组合算法(GBDT, Xgboost, 随机森林) 深度学习算法，一些常见的模型结构以及深度学习的基础知识要了解 其他机器学习基础知识，比如梯度下降，以及AUC计算等等 数学能力 一些基础的概率与数理统计知识。机器学习算法的概率解释。 其中，数学能力的考察其实比较基础和随意，没有什么明确的章法。主要考察的能力是计算机能力和算法能力，下面我将对这两个能力做详细阐述。 不论是面试也好，笔试也罢，毕竟是一次考试。任何考试都一样，都需要花时间去准备才能考出好成绩。所以大家不要对准备考试这件事掉以轻心。下功夫了，自然可以取得好成绩。 计算机能力 计算机能力实际上是面试笔试考察的重点，我这里着重讲一下。 首先，我来讲一下为什么需要计算机能力。 如果想走算法方向，那计算机能力就是我们手中的工具。我们想通过模型解决问题，首先要对要解决的问题本身有足够的了解之后才有可能解决问题。在互联网公司，整体的流程架构，都是由计算机搭建起来的，自然要遵循计算科学的一些基本法则。 模型算法只是在某一个具体的问题上可以得到某一个看起来更科学的解。所以你如果想让你的算法结果对实际生产产生效用，就必须要至少学会能驾驭得了公司的业务流程架构，驾驭得了数据。 比如我们在学习理论模型的时候，总是假设数据从一个假设的总体之中来，输出了一个结果写完了一个报告就算完事。须知生产过程中获取数据可能需要从hdfs中取得，结果可能也需要打入下一个模块之中，这些都是需要代码来完成的。 此外，算法模型是为了优化某个具体的业务问题。首先我们需要做的是把业务的一般解决方法实现出来。这个实现方法可以根据直觉拍脑袋想出一些规则出来，至少可以先实现业务逻辑，使业务方的要求先实现了。如果效果不理想，在后期有精力的条件下，我们可以再对这个问题上算法模型，做一些结果的优化。所以如果想做算法方面的工作，必须要会做一些基本的开发工作。 对于需要的编程语言，这个其实是看团队的。以头条为例，主要的开发语言是C++和Python，需要Java就少一点，但一些其他公司可能就需要Java多点。但就从整体找工作的情况来看，一般是Python + (C++ / Java)。如果只会Python的话，可能会吃点亏，所以建议大家最好学一下C++和Java其中的一个。因为C++和Java很像，而Python相对来说又比较简单，建议大家用C++进行下面的准备；当然，对于只想用Python的同学们，用纯Python通过笔试面试也是可以的，不过也需要写出正确时间复杂度的算法。其实算法这块，算法是个思路，具体你用什么语言实现都是一样的。 对于实习生的要求，一般python就够了，大家不要太过紧张。 考察方式：代码题 其实计算机能力最核心的考察是看你的代码能力。那么如何进行考察呢？就是给你一道代码题，看你对这道代码题的回答怎样，解题的思路如何？知不知道基本概念比如时间空间复杂度？通过考察一道代码题，至少可以确定你知道这个代码中的基本控制结构，熟悉编程语言。最主要的是，在手写代码的过程中可以看你写代码的写的快不快，有没有bug。 面试算法：本质上考察的是数据结构和算法，比如排序，链表，二叉树。对于非计算机专业的同学，面试中不会特别为难你，让你去写一些深搜or广搜or动态规划。如果是计算机专业的同学的要求高一点。因为你用好几年的时间都在研究这个问题，自然要你掌握的牢靠一些。准备面试这件事就是，尽量要准备的多一些全一些胜算就会大一些。所以建议有空余时间的同学还是看一看这些东西，毕竟笔试题还是有可能会涉及的。 需要准备的科目：数据结构与算法。如果完全没有概念的同学建议先学习一些课程；比如网上的公开课或者自己找些书看。 经典教材：《算法导论》。不过比较厚，能啃下来肯定是最好的。 薄一点的教材：《数据结构与算法分析》 有C语言实现的，也有C++、Java实现的，作者都是Mark Allen Weiss。找一个适合自己的教材即可。 实在想看Python的：《数据结构与算法：Python语言描述》作者是裘宗燕。国内作者写的，我觉得废话比较多，体系比较奇怪。不过好在是Python的。自己定夺吧~ 有一点基础的同学：最简单快速的方式是直接刷题。 刷什么题？当然是刷题库。在笔试面试的过程中，有一个非常权威的题库，名叫LeetCode。这个题库搜集的是在硅谷的互联网公司的面试题。我们现在找工作的笔试面试的题库基本都出自这里或者是这里题目的变种。在笔试面试现场屡屡能够命中其中的原题，所以大家一定要好好刷题，认真刷题。不仅仅要看这个代码解题思路， 怎么刷题？当然你可以每道题目都冥思苦想自己做，锻炼自己的思维能力，但是我个人觉得这并不是最有效率的做法。最有效率的做法是先看题，如果短时间内没有思路就直接看答案，对照答案进行反思和体会，然后最好能够在纸上默写解题代码。在面试中，非常重要的一个环节就是手写代码，所以大家一定要注意练习手写代码，和在电脑编辑器上的感觉还是很不一样的。一些资源如下： leetcode代码库1 这份代码库中有一个pdf文件，有作者整理的非常全面的leetcode题目的C++题解，直接拿着这个刷答案即可。pdf文件中的题目可能略有点年代了并没有实时更新，但各个题目都是经典。我用的就是这个。大家可以先看C++的解题思路，再用Python自己实现一下。 leetcode代码库2 这份代码库中是一个新近整理的LeetCode题解，有C++也有Python的解法。甚至还有一些SQL和Shell的题解。应该会很有帮助。 除了LeetCode之外，还值得推荐的是一个国内的刷题网站：牛客网。如果大家将来需要做笔试的话，应该也会在这个平台上进行笔试。所以熟悉一下这个平台肯定也是有好处的。 算法能力 我将分为算法推导、项目经验和主要参考资料三个部分来展开。 算法推导 LR(Logistic Regression, 逻辑回归)，这是机器学习的最基础算法，一定要熟练掌握。默写目标函数，极大似然函数。最好由此出发掌握一些LR极大似然函数的解法，实际上就是常见的凸优化问题的解法。 树类算法(决策树，随机森林，GBDT) 决策树有三种算法，分别是什么？区别何在？节点分叉的是如何判定的？剪枝算法的思路是什么？ 随机森林。为什么叫随机森林？变量重要性如何度量？ GBDT。如何实现？常见的损失函数有什么？Xgboost与GBDT有什么区别？Xgboost为什么速度会快？ SVM。这是一个比较经典的数据挖掘算法，因为比较容易写出推倒公式而被经常考察，手推SVM在前几年是必考题。从目标函数的由来，推到拉格朗日方程。如果面试官要求高，会再细问SMO解法的思路的。 深度学习 BP算法推导，尽量自己可以手推一下 常见的attention的做法以及其解释 深度学习中的一些基础操作，比如初始化怎么做，梯度消失要怎么处理等等 一些其他算法比如DBSCAN和算法工具，比如AUC的计算，ROC曲线绘制等等。 项目经验： 经验在算法岗还是很重要的，所以如果有算法方面的实习那肯定是最好的。此外还可以用在学校期间和导师做的项目以及自己在各类竞赛网上参加的一些比赛来充当自己的项目经验。这些东西也是拿来填充简历的利器。 在面试中，一般面试官都会详细的询问你在自己的项目中用到了哪些算法。具体到你要解决的问题，解决思路，最后的效果及评价指标，以及在项目过程中遇到的难点。这就需要你非常清楚整个算法的解决思路以及曾经踩过的一些坑。如果你回答的有磕绊或者对某些细节没有讲清楚，比如你们没有讲清楚你的特征是如何构造的，那肯定会导致你在面试官的心目中大大减分。毕竟写在简历上的东西应该是你最清楚最熟悉的。所以如果有对简历上的细节不太熟悉的，还需要再斟酌考虑一下。 主要参考资料： 《神经网络与深度学习》 近两年我读过的最好的深度学习教科书了 李航《统计学习方法》。这本书言简意赅，主要的机器学习算法讲的非常透彻。有关的算法推导一定要非常熟悉。 《百面机器学习》、《百面深度学习》。这是两本 公开课 吴恩达的公开课 斯坦福大学公开课：(财富密码)cs229 cs231n cs224n cs234 不懂的问题及时查搜索引擎，有很多技术大牛的博客是很值得参考的。 一些其他能力 以上为大家介绍的，都是计算机能力方面最主要的考察——代码题。此外，可能还会有一些其他能力在笔试面试的考核过程中会涉及。这部分的要求的高度不及代码题那么高，属于入职后肯定会用到，会了会很加分的那种。所以希望大家有时间的话也一定要多看一看，练一练。排名按重要性分先后。 MapReduce, Spark。这是现在最主流计算平台，最基本的使用是需要掌握的。常见的考题有：写一个简单的MapReduce程序（Word Count），hive数据偏斜问题的优化等。 Shell脚本。因为公司的服务器基本都是Linux系统，所以一些Shell脚本是需要掌握的。主要考察的命令有：awk grep sed crontab等。推荐阅读《Linux Shell脚本攻略》 git。这是一个代码版本控制工具，能够方便多人代码的写作和管理。大家可以自己弄一个Github管理自己的代码，平时坚持命令行操作就基本上没有问题了。两个推荐的学习资料如下： 廖雪峰的教程，比较生动形象，但不是特别全。PS：他的Python教程也值得一看。 git教程 这应该是我见过的最全讲的最清楚的git教程。 Vim/Emacs Vim和Emacs是两个不同的在服务器写代码的编辑器，挑一个熟练掌握即可。因为我是Vim党，就不说Emacs的事了。推荐阅读《Vim实用技巧》(豆瓣)。 作者: 峰池，一个爱读书的算法工程师            最近更新： 2021-03-09 06:44:53 "},"chap02/5-choice.html":{"url":"chap02/5-choice.html","title":"2-5 Offer选择","keywords":"","body":"2-5 Offer选择 算法工程师的offer选择，我建议从以下几个角度个角度来思考问题： 公司是否重视？ 直属领导 人才密度 所在岗位的话语权 策略vs算法？ 坦白讲，offer选择可能不是一个很好回答的问题。因为我说不准这个选择会不会让你的人生产生巨大变化。而且这个变化可能真的是天壤之别，只不过在当前的时间点，没人能说出到底哪个是天，哪个是壤。此外，大家一心想追求的知名公司核心部门，其实是在不断发生变化的，普通人很难在当下就可以出预知未来的业务发展。 这种例子实在是太多了：比如腾讯在刚刚起步的时候，移动增值业务，就是彩铃彩信，是公司的饭碗，现在还有这个团队的影子吗？再比如张小龙的微信团队，现在登上神坛，但在这之前呢，在广东做邮箱，你也不会把它当做一个核心部门吧？阿里刚刚开始搞阿里云的时候，内外部都是各种反对各种不理解，这几年谁不知道阿里云到底有多大盘子？ 所以，任何有关对师弟师妹未来的建议，我在说的时候通常都比较谨慎。我的原则是，尽量同步一些我自己知道的信息，还有一些思考问题的角度，尽量少给出直接的建议。 不可避免的是，人们在给出建议的时候，通常会给出那些更能支持自己当前选择的建议。比如我在说是毕业后选择了工作而不是读博，那么我在给建议的时候，就更倾向于工作而非读博；我选择了字节跳动这家公司，那么我在给建议的时候，不自觉的可能就倾向于这家公司本身。这也是没有办法的事情：毕竟如果自己都不相信自己的选择，又怎么可能会给出其他人好的建议呢？除非是自己深知这是一个火坑，劝阻他人不要往里面跳。但一般这种情况会出现的比较少。 公司是否重视 公司的重视与否，体现在，公司是否准备把这个项目当做下一个增长点，以及从上到下对这个项目所报的预期是什么？是尝试的心态呢，还是必须要把这个事情做成的心态。 这意味着公司资源的投入。如果公司大量资源投入进入某一个项目，决定把这个项目做成，那意味着至少两点： 这个项目未来可能会有一大波飞速发展的机会，意味着工作很多，遇到的挑战也会不小。在这种条件下，自身得到的成长将是飞速的。 即使这个项目最终失败了，因为这个项目本身公司投入较多，一般在失败前也会很多试图挽救的点和招。在这种逆境的条件下，积累的经验也是非常宝贵的财富。 所以我个人建议如果可以选择的话，尽量选择那些公司层面比较重视的项目。小公司的重点项目，我个人感觉可能还会比大公司的小项目要好。 直属领导 直属领导可以说是实际工作中的第一任老师。你的绝大多数工作都是从他那里分派出来的，同时这些工作也将会从他那里得到反馈。一个好的老师对人的影响是不言而喻的。 但是在接offer的时候，通常是很难知道这个领导到底是一个什么样的人。这时候就要尽可能的多的搜集信息：比如尽可能的多跟同组的其他同学搭上线，侧面了解一些情况；尽可能的早去实习，实地做一些考察；在网上搜集一些领导过往的履历等等。这个过程中要自己积极主动一点，否则自己入职之后发现被坑了，也挺难受的。 不过大公司的技术leader，一般水平都是很不错的。这一点大家不要过于担心。 对我来说，很幸运的一点是，我工作两年遇到的两个直属领导，都非常优秀，同时也都是非常好的leader。从他们两位这里学到了非常多的东西。 人才密度 对于一个团队来说，人才密度也是非常重要的。因为大家在同一团队之中，这帮人将是你未来重要的合作伙伴。如果人才密度够高的话，仅仅从周围同学中学到的东西，就已经很多了。 这个打听起来其实比较容易，一般越是大公司，offer的难度会越高。相应地，同组的同学的水平也就会越高。以及关于人才密度相关打听起来也比较容易，只需要问一下相关同学觉得同组同学比他厉害的人多不多就行了。 这一条和上一条的本质，都是希望在offer选择的时候，尽可能的可以选择一个相对好的环境。在一个具有竞争压力的环境里，可能自己从领导和周围同事身上学到的东西，就已经让自己受益匪浅了。 所在岗位的话语权 所在岗位的话语权也是一个比较重要的考虑因素。 怎么说呢？如果大家处在一个技术岗位话语权比较高的公司，大家就可以主观的思考某一些问题，然后可以和其他岗位的主动沟通交流，让你的想法落地。如果大家处在技术话语权相对比较低，很有可能技术会沦为产品策略的实现机器，这其实对个人的成长是不太有帮助的。 这个可能要看公司当前的发展阶段，以及内部的文化，大家可以尝试了解一下相关需求，尤其是算法相关的需求是从哪里产出的，以及怎么样推演下来的？ 策略vs模型 在算法工程师offer对比中，可能还会有一种比较，就是会把算法工程师划分成做策略和做模型的，然后机械的评价策略算法工程师不如模型算法工程师。 这种划分一般不会出现在HR口中，更大可能性是出现在从业人员口中的。策略和模型算法工程师一般定义为：做策略的就是要结合业务写一堆if else，然后做模型的就是做模型效果调优。几乎我接触的每一个新入职的算法同学，都希望自己可以成为一个做模型的算法工程师，日常工作包括：训练模型、模型调参，效果调优等等。 我个人其实是不是特别赞成这种划分。因为在我心目中，世上本没有单纯的策略算法工程师或者模型算法工程师，策略只是算法的某种程度上的一种实现手段或者是验证方式。任何算法相关的工作本身都是策略和模型相结合的。 当前，机器学习技术本身可能已经相对成熟了。表现为，传统的一些定义好的问题，比如点击率预估或者观看时长预估问题，大家已经取得了比较通用的解法。如果短期内，机器学习技术如果没有飞跃性的进展，模型效果已经很难取得排除增加机器算力而带来的提升了。意味着，理论上公司应该不会再投入比较多的人力去做训练模型、模型调参的工作了，因为已经差不多到某一个瓶颈了。 那么在日常的工作中，算法工程师更重要的工作是，抽象和定义算法可解的问题。 什么意思呢？我来举两个例子。 在内容推荐场景，有一个比较通用的问题叫做标题党问题：大家是被文章或者视频的标题骗进来了，然后一打开发现不是这么回事，这时候去就不符合预期。一种通用的解法就是审核，就是把每篇文章都让人看一遍，判断是不是标题党。但是这种做法显然费人费力。能不能通过算法的方法去解决标题党的问题？这时候就涉及到，怎么定义标题党的问题(解决正负例的判定)，该收集什么样的特征(特征抽取)，怎么样可以收集一些case去优化这个模型(评价指标)。这样就可以通过算法优化解决标题党的问题。 这是抽象和定义为算法问题的一个例子。为了更好的说明策略和模型的异同，我们再举一个例子： 内容推荐场景有一个问题叫做文章冷启动问题。就是说我们要给所有的文章给一点基础的展现，让这些文章能够积攒一些用户行为，这样这些文章后续才能更加准确的触达给对它感兴趣的用户。此外，让所有的文章有基础的交互也是为了更好的服务作者，不然他们会觉得自己的发文没有人看，从而丧失了后续发文的动力。这是我们对待正常普通发文作者的态度。 但是平台里面可能还会存在一部分作者，他们的目的就是为了来平台薅羊毛，通过发布一些低质量的视频，赚取平台给的流量费。一般情况下，平台都是不会鼓励这样的作者的，因为他们会影响挤占那些原创作者的流量，进而影响整体的作者生态生态。所以呢，我们就要打压薅羊毛的作者，而鼓励那些真心认真原创的作者。 怎么样鼓励和打压呢，这时候可能就涉及到一些所谓的“策略”：我们可能会通过一些if else语句来实现鼓励和打压，然后看一下能到什么样的效果：比如这样的策略可能会让现有的冷启动模型效果造成多少的损失，最大能达到什么样的效果。这个属于策略向的一些糙快猛的探索。可能大家日常诟病的“策略”算法工程师就是在做这样的事情。 但是实际上这个问题背后还可以再深挖一下：比如怎么样去定义鼓励和打压的作者呢？他们有什么行为和特征？怎么样可以更好的实现流量分配的策略呢，是不是比if else可以更少损失更好效果的模型策略呢？这些问题背后其实都是一些可以被算法定义和解决优化的问题。而每一个问题背后，其实都可以抽象成为一个新的模型问题，都可以转化为模型效果和调优的问题。 所以到底是什么造成了“策略”算法工程师的不良名声呢？在实际的工作中，如果只是为了实现产品的需求，那肯定就是if else大师。但是作为一个算法工程师，把一些别人的一些insight，转化为模型算法可解的问题，通过机器学习算法达到更好的效果，那才是算法工程师真正发挥价值的地方。 所以在我看来，算法工程师其实本质上没有“策略”和“算法”的区别，可能产品的想法用“策略”描述更容易实现，但如果单纯的变成一个实现产品需求的机器，那可能也违背了算法工程师的初衷。本质上大家成为算法工程师都是希望用各种各样机器学习算法解决实际的需求和问题的，这时候就需要大家可以再往深的思考一下：“策略”问题，能不能用更好的通过“模型”来解？为了更好的有“模型”效果，通常可以用“策略”做一些简单尝试。 但是一个算法组，如果大家热衷于实现策略，而永远都不关注算法模型的定义，那确实也没有什么前途。为了避免踩坑，还是希望大家能够多了解，多去了解组里的算法氛围。 最后，还要说明的一点是：我们选择某一项工作，是希望通过这个工作本身为他人创造价值，同时在创造价值的过程中积累经验，帮助我们自身成长。但我们不能把自己的成长全部寄托在工作上。无论工作的好坏，我们还是希望自己能够得到最快速的成长。 我们当然有义务找寻一个最适合自己的环境，进而获得最大化的成长。类似于读书时候的孟母三迁以及选择一个好的大学。所以在选择之前多问人，多请教一些情况，这并不丢人。尤其是对于初入社会的同学来说，培养一个好的习惯，以及有机会对公司运营整体运营以及盈利方式有了解，找到其中的价值瓶颈和关键，尝试做出一些改进和贡献，积累行业经验，会更有利于自己的成长。 作者: 峰池，一个爱读书的算法工程师            最近更新： 2021-03-09 06:44:53 "},"chap03/1-basics.html":{"url":"chap03/1-basics.html","title":"3-1 工程基础：线上系统，代码先行","keywords":"","body":"这一章，我们以我自己从事的推荐算法为例，来给大家讲讲工业是如何应用机器学习算法的。主要想让大家明白，这工业应用究竟是怎么跑通的，和自己在学校跑的小数据集有什么区别。 3-1 工程基础：线上系统，代码先行 第一节，先来讨论一下算法工作的基础工程能力。 在本节中，我不会过分深入工程能力的细节，而是希望能够帮你理解一个核心问题：工程能力是一切算法工程师的基础。没有工程，一切都是空谈。以及，我希望能够在本篇大概解释一些工程相关的术语。在后续的行文中，如果这些术语再次出现的，我将会默认大家都已经了解，不再做解释。 基础 那么成为一个算法工程师需要哪些最基础的工程能力呢？那自然是基础的代码能力。 代码能力 趁手的编程语言。Online模块的C++/Java，offline模块的python最好都能熟悉。至少相关语言的标准库，基本语法得会使用。我面试过有些发过论文的同学，结果Python的class都不会定义。真的是只会写TensorFlow了么。 数据结构算法。对代码效率有概念。对常见数据结构及其简单实现有概念，知道这些数据结构的查找插入操作的常见操作的复杂度是怎样的。比如你得至少得知道python的dict背后是哈希表。这样你就能知道它虽然可以去重，但会乱序。 代码实现能力。有时候有的代码题不会考察代码实现的具体算法，而是在知道应该怎么计算的情况下把它实现出来。这是代码实现的能力。常见的函数定义和封装，一些细节如参数的值传递or引用传递都属于此类。实际上是能不能把脑子里的想法翻译成代码实现的能力。 工作场景 下面我以信息流推荐文章场景为例，大致讲一下推荐系统的工程架构。 目前，大多数的推荐系统，都可以分为online和offline两个模块。 online场景讲求效率，一般需要C++或者Java等效率高的编程语言，主要的应用场景是：需要在比如1s的时间内，从海量，比如一千万可推荐的文章中找到用户当下最喜欢那些文章，返回给用户。Online模块通常会包括召回和排序两个大的模块。 而offline模块就是一个笼统的称呼：不在online里面包含的工作，都属于offline的模块。offline的代码语言一般以python等脚本语言为主。使用场景包括但不限于，用户日志的收集与分析、模型的训练、作者新发文进入推荐系统等等。 从工程角度说，主要需要强调一下代码效率，尤其是online模块的代码效率。 代码效率，除了标识着一个码农的专业性以及减少公司的机器开销之外，对于算法工程师而言，在online场景下，代码效率与推荐效果也是挂钩的。 为什么有这个挂钩呢？因为系统排序阶段增加预估条数，一般是可以获得推荐效果的提升的。之所以不全部预估，实际上就是一个延迟和效果的平衡。所以假设你的模块代码写的不好，增加了10ms延时，其实可以兑换成假设排序吃了你这10ms延迟而可以多预估一些文章，带来效果上的收益。而优化代码效率，相应的也可以转化成模型效果指标上的收益，这种收益有时候比模型迭代效果提升容易得多。 工作中80%场景代码效率提升一般都是一些看起来很愚蠢的原因导致的，比如参数的值传递和引用传递、冗余的拷贝构造等。所以，一些基础的细节一定要多注意。这些细节，实际上也是面试喜欢问的，也是为什么算法工程师的面试会那么强调代码能力的原因。 此外，从工程角度，强调一些代码套路也是必要的。比如一些经典的设计模式的原则，详细的可以参考《设计模式》，我这里只列出我觉得比较重要的几个原则。 DRY(Don’t Repeat Yourself)，不要重复你自己。意为在系统中，最好某一块逻辑，在系统中只有一个模块可以对齐进行控制。不要把相同的逻辑重复多遍。这样很容易出现修改只改了一个地方，导致出现不符合预期的情况。这个原则在online serving时候和offline training时候的feature一致性有体现。尽可能的把feature抽取逻辑设计在一处可以最大程度的避免online/offline不一致的问题。 KISS(Keep It Simple, Stupid)，注重简约，别人看了就能用。简单说，如果你自己开发的代码模块，在每次做操作前自己都要check上两三遍，那这个地方大概率是不符合要求的，需要重新设计。这种可以最大限度的排除那些，实验某个策略没有效果的时候，到底是因为策略本身没效果，还是代码没有生效。 代码的组织能力。工作中的代码量显然是比自己平时练手大很多的，对于那些没有大量代码经验的同学。推荐《重构》《代码大全》这两本书。让自己的代码尽可能的更好维护，也更容易让他人读懂。 工具 下面，我来列举算法工程师工作中常用到的一些依赖工具。如果你对这些工具不熟悉的话，可以先自行google了解一下。 HDFS: 对HDFS有基础的了解是必要的。现在的数据肯定都不是单机能带起来的了。 kafka: 流式数据的载体。本质上是一个消息队列。 MapReduce/Spark: 经典的HDFS Batch运算框架。近些年spark这个计算框架已经愈发成熟，成为主流的大数据场景的计算框架了，已经很少有MR能做的，而Spark做不了的任务了。 思考题: Spark为什么会比MapReduce快？ Flink/Spark Streaming: 现在比较流行的流式计算框架。目前好像Flink的势头更猛一点。主要看公司整体的架构的选择。 出于对用户反馈实时性的考虑，算法工程师处理流式数据的场景目前越来越多了，会有比较多的应用场景。 Hbase/redis: 大型Key-Value 存储模块。需要了解日常的交互以及这两个模块的主要功能。 Protobuf/Thrift: Protobuf现在应该是业界比较通用的数据序列化的模块。而Thrift本身除了自身具有的序列化能力之外，通常也会作为Online模块内部RPC调用的一种协议。 推荐资料 对于设计模式没有概念的同学，可以先看《Head First 设计模式》Head First 设计模式（中文版） (豆瓣) 《设计模式》: 有点枯燥，但是经典 设计模式 (豆瓣) 《重构》: 可读性比较强。重构 (豆瓣) 《代码大全》: 书很厚，可以跳着读 代码大全（第2版） (豆瓣) 《设计数据密集型应用》英文名ddia。开源中译本，翻译的不错。一本书读懂数据相关的基础知识。第四章：编码与演化 · ddia-cn 作者: 峰池，一个爱读书的算法工程师            最近更新： 2021-03-09 06:44:53 "},"chap03/2-sort.html":{"url":"chap03/2-sort.html","title":"3-2 排序模块：推荐系统的目标是什么？","keywords":"","body":"3-2 排序模块：推荐系统的目标是什么？ 大家一想到推荐系统，可能第一个脑海中的概念就是，“喜欢这个商品的用户也喜欢”。没错，这一句由亚马逊发扬光大的广告词实际上是推荐系统应用最直观的一种体现。 但首先，我们要定义清楚，什么是用户喜欢，学名叫做用户的偏好。 最简单的用户喜欢，可以是用户的点击。所以有了基于点击率预估的推荐系统的模型。 后来产品形态发生了改变，用户除了点击表达喜欢之外，也可以通过点赞评论收藏关注等等表达自己的偏好。这时候我们出现了，一个item对一个用户可能会有多个维度的喜欢的表达。 我们在定义清楚用户的偏好之后，自然要把所有的候选，按照用户的偏好进行排序。这也是推荐系统排序模块最主要的任务。 一、单目标预估：点击率 点击率这个目标大家其实都已经比较熟悉了，点或不点其实是一个经典的二分类问题。 那么当今推荐系统是如何解决这个问题的呢，而其他的二分类问题的模型结构有什么区别呢？ 首先我们来看排序阶段的模型结构。这个部分可能是推荐系统在线模块中，与在学校学习的机器学习课程中最为类似的一个部分了。我们可以按照自己学校中对机器学习的理解，按照进行模型的training & serving，我们主要来看模型结构。 一句话简单说明，现在排序阶段的模型整体架子都是在Wide & Deep的框架下的一些变体和调整。 什么是Wide & Deep框架呢？这源于Google在16年的一篇论文，Wide & Deep Learning for Recommender Systems。这篇论文非常短，只有4页，核心思想就是这样一张图： 所谓Wide Models，就是所有的特征直接预估得到最终的结果，说穿了就是我们机器学习的第一课：逻辑回归。而Deep Models，就是我们常见的，从最开始的稀疏特征，到变换成Embedding层，到最终的全连接隐藏层，再到最终的输出层。 而Wide & Deep Models，就是把这两个模型结构简单粗暴的融合在一个模型结构里，变成一个大的网络结构。在这个网络结构中，既有Wide的部分，也有Deep的部分。这样的效果通常比我们单独使用Wide 或者单独使用Deep的网络效果要好：比只有Wide的网络结构效果好比较显然，毕竟有deep的部分，拟合的效果自然会好很多；比只有Deep的网络结构效果好，可能的解释性在于，feature直接作用于最终的输出结果，会强化原始的feature在最终预估结果的解释性，尤其会使模型呈现出一种“记忆性”(同样的feature再度出现时，wide部分的网络更容易直接学到结果。) Wide & Deep只是一个网络的框架，一般而言我们会在网络结构中做一些调整和变换，这一点在王喆的《深度学习推荐系统》中有比较系统且准确的介绍。我们在这里先插一张王喆在书中总结出来的图，感兴趣的同学可以深入研究一下。 说几个常用的Wide & Deep 模型的变体： Deep部分加入Attention (DIN) Deep部分加入用户的点击/购买序列，引入Sequence信息，使用类似RNN的操作方式处理Sequence序列等等 (DIEN) 排序模型整体上没有特别深的模型。我个人总结下来有两个原因： 原始的信息输入都是离散特征，比如user_id或者item_id。在这种特征场景下，Embedding层结合三五层全连接已经可以足够表征离散特征的信息了，更深层的网络的优势体现不出来。 深层的网络inference的速度太慢。而inference的速度与效果是呈现反比的。事实上，整个推荐系统在线的部分，模块的延时都可以和最终效果进行换算。因为如果可以在整体耗时给定的情况下，如果排序的候选增加，一般是肯定增加延时但提升效果的。相当于其他模块的延时增加，都可以通过同样的方式进行效果的机会成本的兑换。有时候，因为更多的网络结构带来的耗时的增加所带来的收益，可能敌不过简单的扩大排序候选带来的收益。 模型方面的发展方向是：模型结构使用auto ML的方式搜索出一个合适的模型结构和模型size等等(这个方向叫做NAS， Neural Architecture Search)，而不是再依赖于人手工对模型结构进行调整，就像集成电路设计最终会取代手工设计一样。这个方向目前有一些简单的尝试，但可能距离大规模的工业界的应用，还需要几年的发展时间。 二、多目标预估 以上我们假定的模型预估目标，是单一目标的预估场景，通常都是以点击率为目标做预估的。但是实际上，在推荐系统落地的主要场景中，一般不只有一个目标。比如： 在今日头条这样的新闻类app中，一般除了考虑点击率之外，还会考虑用户在这个文章的停留时长。 在广告推荐领域，一般除了考虑点击率之外，还会考虑广告自身的转化率。 在抖音快手这样的短视频App中，因为产品本身是自动播放的，所以就没有点击率的概念，这时考虑的就是用户是否点赞，是否会看完整个视频等等。 这时候就涉及到两个问题：一是多个目标如何做模型，建模和预估；二是当需要考虑多个模型输出结果的时候，如何确定多个输出结果的权重。 我们分开来看。 多目标建模 首先，多个目标的建模。最简单的解法当然是，多个目标，每一个目标单独建模。比如我们同时预估点击率和时长：就先单独搞一个模型预估点击率，再单独搞一个模型预估时长。 这样的搞法有两个问题： 资源问题，如果每一个模型单独一个模型，需要的资源消耗肯定是比较多的，出于控制成本的角度，我们考虑模型是否可以进行合并。 效果问题，对于比如稀疏的目标，比如广告转化，可能转化率是在千分位左右。这时候如果单独训练一个转化的模型，可能效果欠佳。这时候如果有一个稍微稠密的目标，且表达的信息和用户点击率类似，比如点击率(转化相对点击来说是用户喜好更强的表达)，这时候就可以把两个目标一起训练，可能在效果上还会有一些增益。 这是一个相对来说比较通用的问题，有一个专门研究这个问题的方向叫做Multitask Learning。我这里先说一个有代表性的场景： 假设我们这里有三个目标ABC，彼此目标类似，可以用类似下图的模型结构进行学习。即三个目标有共同的shared的部分，然后又有一些specific的网络结构。ABC三个task的样本，会共同更新shared部分的网络结构，同时也会更新各自独立的网络结构。如果效果好的话，有时候可以起到一个模型，效果比分别三个模型效果还要好的程度。 Multitask Learning 可以玩的花样比较多，具体还是需要在实际的使用中具体调优得到。比如以下几个点： 哪个结构share，哪个结构不share? 除了直接这样hard share之外，也可以使用一些比如软性的约束条件来进行share。 对于有一些目标，我觉得比较重要，我只是想让这个目标去引导另一个目标的学习，而不想让另外那个目标影响我原本这个目标的预估。这是一种teacher & student的模式，通过合理的loss处理以及stop gradient的应用就可以达到目标了 可以设计出更为复杂的网络结构来处理multitask问题。比如MoE or MMoE，就是把门控结构引入Multitask 模型训练。有点类似于把boosting的思想引入网络结构的设计。 以上是一些网络结构的上面的想法，我这里就不具体展开了。感兴趣的同学可以通过我提出的这些关键词，来进行进一步的搜索和学习。简单而言，我们还是预期多个目标每个目标至少可以学准。 多目标融合 接下来我们来看下多个目标的融合。假设我们现在有了比较准确的目标的预估值，比如点击率、点赞率、关注率，那怎么样可以把这两个预估结果比较科学的融合在一起作为最终的排序结果的依据呢？ 这个问题没有统一的回答，因为这实际上是一个产品的决策。 比方说，A这个产品的核心指标就是vv(视频播放量，video view)，那么其实可以不关心用户对某一个视频的观看时长。只需要让点击率高的多出就行了。再比方说，B这个产品的核心指标就是让用户尽可能的沉浸，尽量不进行文章之间的切换，那我就需要让用户最终的排序按照用户的停留时长去排序即可，这样用户在每一个文章之中都可以停留足够长的时间。 更多的情况是，产品需要在多个目标之中做一个权衡。比方说，点击率高的文章，有可能是会遇到标题党，这时候停留时长就不长，用户体验也不好；而停留时长高的文章，可能因为标题封面不吸引人，用户就根本不点进来看。所以我们需要一个方式把多个目标的预估结果平衡起来。 解决问题的办法就是拍一个公式，把点击率和停留时长按照某种方式配比平衡起来。 比如0.3 * 点击率 + 0.8 * 点赞率 或者是 (1 + 0.3 * 点击率) * (0.5 + 0.6 * 点赞率) 等等。这样可以通过一个统一的公式，既考虑点击率，又考虑停留时长。 而如何决定多个目标之间的配比，其实就是一个产品决策问题了。除了要看线上的统计指标之外，可能也需要思考这些内容是不是符合整体的产品生态等等。这个问题就太大了，脱离了入门的范畴了。 作者: 峰池，一个爱读书的算法工程师            最近更新： 2021-03-09 06:44:53 "},"chap03/3-recall.html":{"url":"chap03/3-recall.html","title":"3-3 召回模块：海量候选的快速匹配","keywords":"","body":"3-3 召回模块：海量候选的快速匹配 在第二节我们简单讲了一下现在推荐系统的目标。假设我们拥有无穷的算力的情况下，采取这种方式计算出来的结果一定是最优的模型推荐效果。 但是现实是，我们不可能拥有无穷的算力。 如果你是第一次了解推荐系统，我先来简单解释下。以新闻推荐为例，推荐系统的目标是从千万甚至更多的新闻候选集中，挑选出用户最可能感兴趣的k篇新闻。(下文为了论述简单，我会默认k=10)。而整个过程，需要在非常短的时间，比如1s内，完成全部的计算。大家可以想象一下下拉刷新时候的那个等待时间，如果这个时间太长，用户肯定不愿意等下去。 出于平衡效果和延迟的原因，现在的推荐系统大多把它划分为召回和排序两个阶段。 召回是从候选集中找到用户可能会感兴趣的过程，目的是把千万甚至更多的候选集，变成千级别的候选。 排序是接受用户召回的千级别的候选再排序，从中用户最可能感兴趣的10篇新闻。 所以，召回阶段面临的问题是，怎样可以快速从海量内容中找到用户最感兴趣的Top k的候选。 有一些经典的推荐系统的算法，比如协同过滤，包括用户协同过滤(和你相似爱好的人也看过什么)和文章维度的协同过滤(看过你看过的文章的人还看过什么)，这些算法也是可以用在召回阶段的。这些算法在横空出世的时候也是名噪一时无人能出其右。但是现在，这些算法在实际应用的问题中或多或少的会面临一些问题，比如用户协同过滤容易把人都相似到一些全局最活跃的用户上，而文章协同过滤则没有考虑到当前用户的喜好。所以已经渐渐地被业界淘汰了。 目前在召回阶段基本都是通过向量化召回找到用户最感兴趣的内容。而这个向量怎么训练和得到呢？我们来从经典的FM召回谈起。 从FM谈起 对于不熟悉FM这个算法的同学，我强烈建议你们补补课。这是推荐系统近十年来可以说最为划时代意义的一种方法。后面你会发现，所谓深度学习的一套算法，只不过是在FM基础上做了一些搭积木的工作。 谈起FM(Factorization Machine)，如果要从理论上追根溯源的话，有点类似于LR(Logistic Regression)。 在推荐和广告领域，预估的目标是二分类问题(用户是否点击)，特征基本都是网络上的属性特征——离散值比较多，而连续值比较少。在这种场景下使用LR做预估，通常的做法是要把离散特征变成一个个虚拟变量，然后进行逻辑回归。 写成数学形式是这个样子的 yi^(x)=w0+∑iwi∗xi \\hat{y_i}(x)=w_0+\\sum_iw_i*x_i ​y​i​​​^​​(x)=w​0​​+​i​∑​​w​i​​∗x​i​​ 在这种数学表达形式下，各个特征都是独立考虑的，并没有考虑到特征之间的相互关系。但实际上，特征之间是有可能有相互关联的，比如男性用户一般会比较喜欢游戏，而女性用户一般会喜欢时尚。为了建模这种相关性，可以在模型中引入二阶项 yi^(x)=w0+∑iwi∗xi+∑i,jwijxixj \\hat{y_i}(x)=w_0+\\sum_iw_i*x_i+\\sum_{i,j}w_{ij}x_ix_j ​y​i​​​^​​(x)=w​0​​+​i​∑​​w​i​​∗x​i​​+​i,j​∑​​w​ij​​x​i​​x​j​​ 但这种加入二阶项的方式有一个问题，原始的特征比较稀疏，比如有一个女性用户喜欢Dota2，这种样本可能会在原始数据集中非常少见，会导致二阶项wijw_{ij}w​ij​​学习的非常不准确。 为了解决这个问题，FM引入了一个类似矩阵分解的思路，给每一个类别变量引入了一个向量vvv，把上述式子变成了这个样子 yi^(x)=w0+∑iwi∗xi+∑ij⟨vi,vj⟩xixj \\hat{y_i}(x)=w_0+\\sum_iw_i*x_i+\\sum_{i​y​i​​​^​​(x)=w​0​​+​i​∑​​w​i​​∗x​i​​+​ij​∑​​⟨v​i​​,v​j​​⟩x​i​​x​j​​ 这样做为什么可以有效呢？ 我们来想一下这个v的更新，还是女性用户和Dota2的例子，女性用户的所有样本可以更新vfemalev_{female}v​female​​，而Dota2的样本可以更新vdota2v_{dota2}v​dota2​​，这样即使在样本稀少的时候，只要女性和Dota2的样本分布够多，理论上⟨vfemale,vdota2⟩\\langle v_{female}, v_{dota2} \\rangle⟨v​female​​,v​dota2​​⟩ 也可以生成正确的预估结果。 至于v向量维度选择的数学依据，其实矩阵分解有关，我们这里就不提了。如果对此有疑问的同学，可以参考文末的参考文献来学习。在实际的应用中，v的维度大多数情况下是一个实验出来的超参数。 FM在推荐系统中的应用 推荐系统中，最主要的问题其实是user和item的匹配问题。而最能体现每一个用户或者物品独一无二性的，其实是用户侧的user_id，和物品的item_id。如果一个推荐系统能够很好的学习到user_id和item_id，那么这个推荐系统一定是非常准确且稳定的。 所以我们来看一个最简单的FM模型：只有user_id和item_id的模型。我们可以把user_id和item_id套入上面的FM公式，可以得到这样一个变换： yi^(x)=w0+∑ui∈userwui∗xui+∑ij∈itemwij∗xij+∑ui∈user∑ij∈item⟨vui,vij⟩xuixij \\hat{y_i}(x)=w_0+\\sum_{u_i \\in user}w_{u_i}*x_{u_i}+\\sum_{i_j \\in item}w_{i_j}*x_{i_j}+\\sum_{u_i \\in user}\\sum_{i_j \\in item} \\langle v_{u_i}, v_{i_j} \\rangle x_{u_i}x_{i_j} ​y​i​​​^​​(x)=w​0​​+​u​i​​∈user​∑​​w​u​i​​​​∗x​u​i​​​​+​i​j​​∈item​∑​​w​i​j​​​​∗x​i​j​​​​+​u​i​​∈user​∑​​​i​j​​∈item​∑​​⟨v​u​i​​​​,v​i​j​​​​⟩x​u​i​​​​x​i​j​​​​ 回到我们的召回场景。问题本质上是，当user给定的时候，找到系统中得分最高的item。所以上式中的几项实际上可以拆分为 给定user与排序无关的项 w0w_0w​0​​, ∑ui∈userwui∗xui\\sum_{u_i \\in user}w_{u_i}*x_{u_i}∑​u​i​​∈user​​w​u​i​​​​∗x​u​i​​​​ 真正决定item顺序的项 ∑ij∈itemwij∗xij\\sum_{i_j \\in item}w_{i_j}*x_{i_j}∑​i​j​​∈item​​w​i​j​​​​∗x​i​j​​​​ 和 ∑ui∈user∑ij∈item⟨vui,vij⟩xuixij\\sum_{u_i \\in user}\\sum_{i_j \\in item} \\langle v_{u_i}, v_{i_j} \\rangle x_{u_i}x_{i_j}∑​u​i​​∈user​​∑​i​j​​∈item​​⟨v​u​i​​​​,v​i​j​​​​⟩x​u​i​​​​x​i​j​​​​ 当vuiv_{u_i}v​u​i​​​​给定时，把bias项wijw_{i_j}w​i​j​​​​合并入向量极端。最终决定每一个item的排序结果会变成一个向量的内积： ⟨(vui,1),(vij,wij)⟩ \\langle (v_{u_i}, 1), (v_{i_j}, w_{i_j}) \\rangle ⟨(v​u​i​​​​,1),(v​i​j​​​​,w​i​j​​​​)⟩ 所以一个FM模型的训练结果的召回问题，就转化成为一个内积运算找Top k的问题。而内积运算，可以很轻易的转化为cos距离。这个问题就更加进一步的转化为，给定一个user向量，找和它距离最近的Top k的item，也就是我们熟知的kNN问题。 这里顺带说一句，FFM召回作为FM召回的变体，和FM召回实际上是相通的。 向量化召回 在把向量化召回的问题转化为kNN的问题之后，其实我们已经把这个问题解了80%，剩下的就是看怎么样优雅的解决这个kNN问题。 当然kNN这个问题不仅局限于推荐的召回场景。更一般的场景是，比如在搜索中，针对给定的query，怎么从海量候选中找到和这个query最相关的候选结果。 kNN是一种实践和理论结合的典型问题：实际应用中有需要(解决大量候选的召回问题)，于是可以把这个问题抽象成一个具体的数学问题。然后设定benchmark，学术界和工业界一起不断迭代优化，成为一个具体的研究方向。 具体这个问题的数学形式可以定义为以下的样子： 给定N个维度是f的向量(vector)组成集合S 给定一个距离函数d，其中 d(a, b) 是向量a和b的距离，距离越小表示a，b越相似 输入一个维度是f的向量q，如何找到S中和q距离最近的K个向量 首先暴力计算肯是不行的。暴力计算就是维护一个大小为k的堆，然后遍历所有的候选，这样的时间复杂度是O(Nlog(k))。当N非常大，比如千万级别的候选，显然查询是非常慢的。 常见的kNN的优化算法有以下几种： kd-tree: 这是最经典的kNN的查询算法。基于坐标轴进行二叉树分叉，这样可以快速的把所有候选划分到不同的超矩形中。进行查找时，根据二叉树快速找到的二叉树子节点。但是当向量维度比较高时，这种算法一般效果比较差。 ball-tree: 实际上是kd-tree的一种改进。不再局限于坐标轴的分叉，沿着一系列的hyper-spheres来分割数据，空间中可以用球来表示。每一个子节点中有一个代表中心的节点，以及一簇候选。进行查找时，先比较目标向量与众多划分出来的球型结构的中心节点的距离，找到最近的中心节点，然后再在这个球型结构的候选中找最近的k个候选。 HNSW: 先说NSW，先把候选根据距离构建成一个图，构建时距离最近的点被连成了边。进行查找时，先随机选择初始位置，然后沿着边即可递归的找到所有的最相近的候选；HNSW是在NSW的基础上，加入了层级信息，类似于引入了索引，加快了搜索的速度，以及落入奇怪连通分支的概率。 囿于篇幅，我们不展开说这几种相似算法具体的实现细节了。感兴趣的同学可以在文末的参考文献找到这几种方法的原始论文，看下实现细节。 不过需要注意的一点是，不管这三种的哪一种方法，都是需要离线计算的——不管是kd-tree的方形结构，还是ball-tree的球形结构，抑或者是HNSW的层级结构，都需要先在离线准备好这样一个结构；才可以实现在线的快速计算。 这其中有两个问题： FM模型的更新怎样可以联动这个召回的离线结构的更新 构建离线结构的速度不能过慢，需要让FM模型的更新可以及时的反馈到这个离线结构上 具体在实现中哪个效果好，还是要结合自己的数据和实验效果，进行取舍；同时还要方便测试和迭代，不同的应用场景肯定效果是不同的，没法一概而论。 双塔召回 上文我们着重讲了FM模型到向量化召回的由来。现在都是深度学习时代了，有没有可能在召回侧加一些深度学习的网络呢？ 需要注意的一点是，除了我们要训练出一个各项指标优秀的模型之外，我们还需要尽可能的保留转化为向量化召回的操作空间，否则等待我们的就是百万候选集上的暴力计算。所以，一般意义上的Wide & Deep肯定是不行的。 所以，目前业界的一个比较通用的解决方案是: user侧接一个塔，item侧接一个塔，然后两个tower的顶部，把两个tower的结果做点积。这样就是一个，接了深度网络(保证效果)，同时在user侧和group侧分开计算(保证可以进行kNN运算)的召回模型了。 比如YouTube的这篇经典的论文，这边有好多特征其实都是user侧的feature，实际上是user侧的tower。group侧的特征在这张图里都没有出现。 当模型变成双塔后，进行向量化召回的item侧塔的knn结构构建的时候，就不再是以item_id对应的embedding做构建了，而是需要把每一个item的特征的原始值收集起来，先一起forward得到item侧最终要和user侧进行点积的embedding。然后再用这个embedding进行kNN相似结构的构建。 同样，user侧需要最终执行kNN相似计算的，只是user侧最终的embedding，这意味着user侧也可以在召回运算进行之前进行一些预计算，得到最终的user_embedding。这样召回侧的实际计算，依然也就变成了user_embedding * item_embedding的经典kNN问题了。 召回阶段的一些其他问题 在YouTube的论文中，召回问题被看成了一个多分类问题。这篇论文中对于召回问题的解法，类似word2vec。在损失函数换成了多分类的softmax之后，为了解决计算效率问题，采用了随机负采样和层次softmax来优化。这种解法更像是一个nlp领域的解法，并且softmax生成的embedding的用法与FM生成的embedding的用法基本类似。这里就不在具体的说明了。 本文讲述的只是FM召回的演化过程。实际应用中，除了这种召回可能还会有其他类型的召回，比如通过item2vec根据文章的相似性来找回，整体的思路与本文伦论述的FM召回大同小异。 参考文献 YouTube论文: https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/45530.pdf FM论文: https://cseweb.ucsd.edu/classes/fa17/cse291-b/reading/Rendle2010FM.pdf ball-tree: https://arxiv.org/pdf/1511.00628.pdf hnsw: https://arxiv.org/pdf/1603.09320.pdf 最后总结一下这篇文章。这文章中我们讲了基础的FM模型，以及如何从FM模型发展成为一个向量化召回问题，最终深度化变成双塔召回模型。 作者: 峰池，一个爱读书的算法工程师            最近更新： 2021-03-09 06:44:53 "},"chap03/4-instance.html":{"url":"chap03/4-instance.html","title":"3-4 样本拼接&模型训练","keywords":"","body":"3-4 样本拼接&模型训练 前两篇文章我们讲了online的召回模块和排序模块，解决了模型如何进行应用的问题。这篇文章我们来详细聊聊，这些在线模块使用样本是如何产生的，模型是如何训练以及更新的，以及这个过程与自己单机跑的模型有什么异同。 对于缺少实际场景工作经验的同学来说，对于模型训练的认识会是如下的流程：在一个大的数据表中，比如一个2万行的一个csv表格，这个表格中有相关的feature和label。我们这时候使用某些软件包，比如pandas，直接把所有的数据全部读入到内存中，然后调用类似xgb.train()这样的方法，就可以得到效果还不错的模型。大家的模型相关的调优工作主要体现在，模型相关的参数是如何选择。 但是，在实际的工作应用中，一个最大的问题就是，样本不是从天而降的，而是需要生成的。而且它的数据量通常会比较大，可能无法被直接读入到单机的内存中，这时候就需要分布式计算，进行参数的更新和调优了。 所以这篇文章主要想解决以下三个问题： 样本是如何产生的？ 模型参数是怎么进行更新的？ 对在校同学可能更感兴趣的是，分布式计算的相关理论，是如何在实践中发挥作用的。 样本生成 我们首先来看样本生成的问题。 推荐系统的目标是拟合用户的喜好，而用户的喜好则是通过用户的各种行为表达出来的。所以我们的label自然是各种各样用户的行为。 用户行为是用户在手机的App上进行进行各种交互的结果，常见的用户行为包括比如点击，停留时长，点赞，评论等等。在用户在手机App(我们把它叫做客户端)上进行了这些操作的时候，客户端会发送一条事件来记录这件事的发生：即某一个用户(UserID)，在某一个时刻(time)，对某一篇item(itemID)，产生了某一种用户行为(Action)。 在用户量级比较小的情况下，我们可以把这个事件直接写入某一个数据库中，比如MySQL，作为真实的Label存储下来。但是，因为写操作通常比较耗时，且写的并发数通常不能太大。为了保证客户端上的行为记录的准确性和稳定性，我们通常要把时间生成与写入事件分离。通常会选择通过消息队列的方式来实现：客户端因为事件产生而发送消息，服务端接收这个消息，负责存储。目前用的最常见的分布式消息队列，是kafka。 于是我们现在就有了比较准确的用户label。 Feature大家应该都比较熟悉了，我们在线做预估的时候，已经生成了这些feature。出于与事件生成与事件写入分离类似的考虑，我们也通过消息队列，把feature存储下来。 这时候我们就有了一份完整的feature和完整的label，然后我们就可以根据它的UserID和itemID，对这两者进行拼接生成完整的样本了。 所以在线系统的完整的流程就是：我们先对一批item进行预估，排序得到最好的item返回给用户，用户再根据自己的喜好，对这些item进行反馈。然后收集这些用户行为，生成新的样本，更新模型，帮助我们对下一批的item进行预估。这个过程有点自我改进迭代的味道。 到这里，可能大家会觉得不过如此：好像一切都还挺在掌控之中的？ 那可能是因为大家遗漏了比较关键的一个点：推荐系统的实时性。 在用户在客户端进行了一次反馈之后，我们总是希望模型可以尽快的学到这一种偏好。比如用户之前可能是一个看做菜比较多的用户，他可能出于某种原因突然关注了美国大选的结果，我们希望模型能够尽快的学到用户的这个偏好，短时间内给他多出一些美国大选相关的新闻，这样可以更好的吸引用户。 这就意味着我们的样本生成要尽可能的实时。但是这个在技术上是有难点的，在样本的角度考虑的主要问题在于：等多久？ feature的生成是实时的，在进行预估的时候，feature实际上已经产生了。而label是什么时候产生的呢？这涉及到用户通常需要多少时间对推荐出来的item做出反馈。此外，通常用户一次请求返回的item条数通常不止一个，意味着我们要等用户对所有的item都做出反馈才行。 所以，在生成样本的时候，通常是一个feature等待label(用户行为)的状态。 等一天？用户行为肯定是准确的，但对模型来说，实时性太差了。 等五分钟？对模型来说，实时性是够的，但是用户行为真的准确吗？可能还有3个item用户都没来得及看呢，如果我们在五分钟内做结算，这三个item肯定会因为用户没有足够的事件做反馈而被当做负例。用户后面如果真的看了，用负例结算就是非常不符合预期了。 等一个小时？看起来好像可以，但是怎么衡量这个数值对不对呢？ 这时候我们通常需要确定用户的行为需要要在多少时间内回收。这实际上是一个模型实时性与样本准确性做的trade-off。这个通常需要根据推荐系统的应用场景来做决定。 此外，因为我们要保证推荐系统的实时性，我们可能需要使用分布式的流式计算框架来进行样本的拼接，现在比较流行的计算框架是storm和flink。 模型的参数如何进行更新 在有了样本之后，接下来的问题就是模型如何进行更新了。 有同学会说，模型的更新还不简单：直接tf.Session.run()，一把搞定。 在单机情况下可以这么搞，所有的参数全部存储在内存中。但当样本量非常巨大的时候，意味着我们需要管理和维护的参数空间会非常的巨大，比如可能单个模型就需要10T左右。这时候单机显然是吃不消的，这时候就需要分布式的计算框架来做操作。 我们来看训练模型需要做哪些事情： 根据给定的feature，先得到网络中参数 做forward操作，得到预估值 根据预估值与实际的label，得到梯度 梯度backward 根据梯度更新网络中的参数 其中234是我们相对比较熟悉的，主流的深度学习计算框架比如tensorflow和pytorch都可以做相关的操作。1和5，尤其是5，是我们这里需要提一下的。5的点主要在于，在分布式的情况下，怎么样可以汇总所有分布式计算worker中的梯度。在有了梯度之后，其实具体的更新方法是大家比较熟悉的，其实是优化算法的实现，比如FTRL, Adam等等。 为了解决1和5的问题，我们需要一个参数管理器，主要支持两个操作： 给定feature快速读取网络参数 支持参数的梯度更新，尤其是梯度的计算 为了解决这两个问题，李沐在2014年提出了Parameter Server，是机器学习分布式训练的一个重要解决方案。 Parameter Server是什么呢？首先它是一个key-value的分布式的存储单元，可以支持给定feature快速读取网络参数。其次他提出了一种“异步非阻断式”的梯度更新方法，可以快速的提升梯度更新效果。 这个梯度更新方法有啥玄乎的呢？我们要从分布式计算的基本原理讲起。 我们知道，分布式计算中有一个重要的理论叫做CAP定理，它是指在一个分部式系统中，以下三个要素最多只能实现两点： C(Consistency，一致性)：多个分布式的节点中存储的数据是一致的。 A(Availability，可用性)：主要是指可以实时取到节点中的数据。 P(Partition tolerance，分区容错性)：能够容忍节点通信之间的网络故障。 CAP的原理，即为什么只能实现三点中的其中两点，我们在这里不多展开了。感兴趣的同学可以下面再了解一下。 我们要说明的是，在实际的梯度更新计算的场景，我们首先是必须要选择分区容错性(P)的，因为在工业界单机故障可能是一个比较常见会发生的事情，通常我们通过多副本来实现；其次在我们的场景，可用性(A)肯定是也要选择的：毕竟我们每次梯度更新forward和backward的核心就是要拿到已有的参数取值。这就意味着在一致性(C)这个维度，我们可能得做一些舍弃。 一致性对梯度更新意味着什么呢？我们在单机进行梯度计算的时候，每一个minibatch产生梯度之后，可以直接更新原始的模型参数。但是在分布式环境下，在多个计算节点(也就是worker)中，每一个worker都会产生当前worker接收的样本的对应的梯度，如果直接对参数进行更新，因为缺乏一致性的保障，可能会导致多个副本中的参数完全不一致，直接导致网络就会错乱。 为了避免这种情况，人们引入了一个中间层Server，用来接收所有worker产生的梯度。先让所有的worker读一个minibatch的数据，然后全局进行等待，等所有的worker把梯度计算完了之后，把梯度做一个汇总，统一更新所有的模型参数。然后所有的worker再统一读入下一个minibatch，进行计算。这其实就是Spark MLlib的实现方式，叫做“同步阻断式”的实现。 这个实现方式比较直接，也是最能保证一致性的实现：这个计算结果会和串行的计算结果完全一致。但是有一个问题严重的问题就是：慢。实际的运算过程中，worker的计算有快有慢，大量的时间都浪费在等待慢的worker的梯度计算了。 Parameter Server在这个基础上提出了一个改进：叫做“异步非阻断式”，相当于是在Spark MLlib和完全自由的梯度下降之间取了个折中：Server还是存在，不过相对spark MLlib的实现方式，server不仅仅是做梯度汇总的工作，同时还做指挥调度worker的作用。通常情况下，worker读取minibatch计算，梯度传递给Server，Server端做统一的处理和调度，决定worker是否需要继续计算下一个minibatch。server允许快的worker多计算几个minibatch的样本，即使可能上一个minibatch的计算结果还没有来得及进行参数的更新。当然，Server侧如果发现，某一些worker计算实在是太快了，比如落下后面的worker10个minibatch，server就让他们等一等。避免参数完全错乱的情况出现。 大家发现，这种实现方式，实际上是模型参数一致性和计算效率之间的取舍。这种方式在实践过程中被证明是：一致性上虽然有损失，但是计算效率和模型收敛速度上，都是极大的优于之前的实现方式的。 同时，Parameter还使用了一致性哈希等等一些技巧，最大化的利用了带宽，避免计算瓶颈的出现。这个就留给感兴趣的同学进一步了解吧。 总结 这篇文章主要给大家讲解了样本生成和模型更新的一些知识。 某种程度上说，有点偏“工程”，不那么“算法”。但工程属于是算法的基础，一个算法工程师首先是一个工程师。对于一个想在工业界发展的算法工程师而言，熟悉并掌握工程基础是必要的。 很多准备做算法或者刚刚开始做算法的同学会有一种错觉：觉得自己训练一个特别NB的模型，就可以解决业界90%的问题，受到大家的顶礼膜拜，自己也会因为这个模型而名满天下。 但实际上，在日常的工作中，纯“算法”需要的开发其实并不多，日常的有很多不那么“算法”的工作需要细致的开发和探索。熟悉并掌握线上的系统，是做好算法工作的前提。很多时候，你精巧训练的一个模型带来的增益，可能很大程度上不及把样本生成搞对，或者是模型训练参数设置正确带来的收益更大。可以说，工程能力，是为算法创造价值打下的基础。这也是大家在面试算法工程师的时候，为什么把以代码能力为主的计算机能力看的这么重的原因所在。 在业界工作与学校的最大区别在于，学校看重创新，会鼓励新的想法和点子；业界看重产出，希望能够带来实际的效果和增益。一个好的模型的idea，在学校可能会受到追捧，但是如果不能落在业界的产出上，是不会在业界的评价体系上占到优势的。而取得实际的效果和增益，如果可以通过工程上的一些技巧快速的达到，可能会比一个精巧但耗时的模型更能取得业界的青睐。这也是我们需要重视工程能力。 这并不是说作为算法工程师，算法不重要。掌握工程架构，理解业务，在这个基础上发掘数据的价值，定义算法目标，最终解决实际的业务目标才是算法工程师的价值所在。 作者: 峰池，一个爱读书的算法工程师            最近更新： 2021-03-09 06:44:53 "},"chap04/write_to_new_engineer.html":{"url":"chap04/write_to_new_engineer.html","title":"4-1 写给新人算法工程师","keywords":"","body":"4-1 写给新人算法工程师 这篇文章主要希望回答这几个问题： 入职初期的挑战，以及如何进行克服？ 关于“萌新”心态 工作之后觉得自己成长最快或者最大的收获是什么？ 最想跟学弟学妹说的一句话 一、入职初期的挑战，以及如何进行克服？ 坦白的讲，在入职的时候肯定是有挑战的。我司对于新同学来说，一般来说，在刚入职的一个月基本都是不会有任何产出的。我个人感觉最大的挑战是在于熟悉整体的业务流程，主要是指有非常大量的代码需要熟悉。这对于之前没有大量代码经验或者工程经验的我来说简直就是噩梦。 不知道其他公司的文档建设怎么样。至少在我司，在我刚来的时候，新人文档建设方面做得是比较差的。组内盛传的一句话是：代码是最好的文档。经常你问组内大佬一个业务问题，大佬随手又甩给你一个你之前没见过的代码库，说你看了这个就好了。 遇到问题本身还是没有什么捷径的，就是比别人花费更多的时间去学习努力。此外我还发现，组内资深一点的同学在晚上九十点左右当天的手头的工作差不多结束的时候，是会非常nice的给你讲解你的一些可能非常愚蠢的问题的。这个过程中不要害羞，要勇于开口，不要不好意思。当然要确保自己的问题是自己思考过的，不要问一些简单查一些文档或者Google可以解决的问题。不要把别人的nice当做自己偷懒的理由。 自己多做整理。很多同学看到了新人文档建设不全面，自己就开始疯狂抱怨，仿佛这就是新人进入状态慢的理由。我当时的做法是，把自己踩过的坑和询问资深同学得到的结果整理了出来，整理成了我们组第一份比较详细的新人文档，后来的很多同学都是按照我整理的这一套文档熟悉工作的。很多你自己踩过的坑可能是后人们也会踩的，成就他人。同时自己经过整理后的东西，自己的印象也会非常深刻，对整个系统的了解也会更加深刻。 其实做其他工作也是类似，如果看到了现状的不足，不要去抱怨，你能发现的不足，其实也是你的工作可以发挥作用的地方。 二、关于“萌新”心态 很多新入职的同学喜欢以“萌新”身份自居。好像自己做事情比较慢，有bug，不及预期都是符合预期的，毕竟自己是“萌新”嘛。 我其实比较反感新人以“萌新”心态自居。首先大部分新人并不萌。其次，在代码面前，任何人都是平等而严肃的。线上并不会因为你是一个新人而减少出bug的概率。 此外，公司给大家发一样的钱，难道就是为了让你自己在这里“萌”自己么= =其实“萌新”应该也只是自己对自己的定位，组内的其他同学，应该大概率不会把你定位为“萌新”的。自己这段时间在带一个刚刚入职的校招小朋友，我就恨不得他赶紧能成为一个能够独当一面的年轻人。 “萌新”与否的关键在于心态和责任心。如果你觉得自己是个“萌新”，那你可能觉得自己做事情可能就是会欠考虑，有bug等等，线上有问题了自己为什么要去参与。但说白了，所谓的“萌新”也只是业务经验缺乏的年轻人罢了。可以因为不熟悉而工作效率低，可以因为不熟悉而发现问题慢，但如果因此导致自己做事情的完成度上欠缺，那肯定是不符合预期的。 因为不熟悉而慢可以学习，但除此之外，不要因为自己是新人而给自己太多的借口。要勇于承担责任，别人才会放心把工作交给你。 三、工作之后觉得自己成长最快或者最大的收获是什么？ 感觉最大的收获在于，不要给自己设限。 无论你入职是在什么岗位，你可能手头有一些自己的本职工作，这些是你肯定要做好的。除了完成自己的本职工作之外，如果看到了有自己不满意的地方，就尽可能的参与改善。同时尽可能拓展自己的眼界，不要给设限。当然，第一优先级永远是自己的本职工作。 举个例子，我是做推荐的同学，在众多需要优化的指标中，非常重要的一项就是点击率。但是，推荐返回给用户内容，除了内容本身之外，样式本身也会是影响点击率非常重要的一个因素。如果意识到之前的样式存在什么样的问题或者缺陷，这时候可以主动找产品同学聊，提出自己的一些想法。说不定你对产品的想法的提升甚至会比你手头工作的价值更大。 工作的目标整体上是为了给产品创造出更大的价值，可能你手头的工作的优化是一直在优化局部最优解。但如果你能跳出来，主动获取一些上下游的信息，是可以找到更大的最优解的。比方说，如果你发现了增长的瓶颈其实不在算法，而是在产品设计的某种机制上。你发现了这个现象，并且用数据证明了你这一点是正确的，那说不定就会为公司创造更大的价值。大家常说的有产品sense就是在指这一点。 这些上下游的信息本身不难获取，其实可以主动和组内资深同学进行沟通，或者可以跟跨组的同学多聊两句，其实就可以得到了。 某种程度上，我们虽然是算法工程师，但不要把自己局限于自己非得只能做算法工程师能做的活。本质上，我们是要为公司创造价值的。每一项岗位的职能可能会随着技术的发展发生变化，但是创造价值公司才能收益的整体大逻辑是不变的。解决问题有很长的链路，在这个链路中，任何一环创造了价值，都可以最终影响结果。所以，不要死守着自己的一亩三分地，可以尝试尽可能多的创造价值。这样，才能获得最终价值的提升。 四、最想跟学弟学妹说的几句话 一、成长是自己的事情。这是我司内部非常资深的一位大佬在我们刚刚入职的时候给我们分享中提到的。 什么意思呢？我们需要自己安排时间充电，自己去研究自己感兴趣的东西。我了解到的，公司很多身居高位的大佬周末的时间还会找到最新的paper进行研读。 公司是没有义务既付给你工资，同时还帮助你成长的。如果你的成长不及公司的预期，公司完全可以再找一个更符合预期的人来做创造价值的优化。所以业余时间还是该充电充电。 同时，自身业务经验的积累也很重要，要多做总结。通过总结梳理出来哪里做得好，哪里做的不好。这样积累和沉淀下来，自己的经验也会愈加丰富。 二、不设边界，多多突破自己的舒适区。这一点我其实前文已经提到了挺多了。你要相信公司周围同学，包括你的领导和同学都不是傻子。如果能够为公司创造价值，一定是会获得机会，得到提拔和重用的。 不设边界还体现在，虽然你有自己的本职工作，但你也可以观察周围同学的一些做法，可能是同组的同学，也可以是业务线上相互合作的产品或者服务端同学。他们具体的工作，自己可以做一些思考：如果是自己做同样的工作，会用什么样的方法。可能方法一致，那就可以观察那位同学在做事最终是否work，过程中遇到了哪些问题，怎么样去克服的；可能方法不一致，那么自己的做法是否比他的更好，最终的效果是否可以证实自己的判断。 他人做事的结果，也可以作为自己的经验辅助积累。这样自己成长的速度也会快人一步。 三、做一个靠谱的人。什么叫靠谱？ 两层意思：第一层，老板交代的任务可以按时保质保量完成，这是第一层的靠谱。 更高级别的靠谱是，老板交给你一个任务，你搞明白为什么会有这个任务，从这个出发点去考虑，还有什么问题是老板之前给出的思路之中没有包含的。然后你不仅按照老板的意思完成了任务，同时还顺着问题的思路就问题进行了更深刻的思考给出了自己的看法。那就是一个非常靠谱的同学了。 如果大家都认为你是一个靠谱的同学。放心，你的工作和任务会越来越多的。与之相应的，你的级别和等等可能你之前关心的那些“身外之物”也会随之而来的。 作者: 峰池，一个爱读书的算法工程师            最近更新： 2021-03-09 06:44:53 "},"chap04/2-how_to_make_money.html":{"url":"chap04/2-how_to_make_money.html","title":"4-2 商业模式：互联网如何赚钱","keywords":"","body":"4-2 商业模式：互联网如何赚钱 算法工程师的职业发展，是和算法工程师能为企业带来多大的价值正相关的。怎么样可以为公司带价值呢？在商言商，公司的利润无非=收入-成本。所以我们就从收入和成本两个方面来考量一下算法是否有什么发挥的空间。 对于大多数互联网公司而言，边际成本通常比较低，所以如果能够把控住收入，基本上也就等于把控住了利润。所以我们这篇文章就先重点分析一下收入的影响，然后再谈谈在成本控制上，算法可以发挥作用的地方。 为了讨论简单起见，下面的讨论我们都以To C的内容消费类的App为主：典型的代表就是抖音快手、今日头条、西瓜视频。 现在比较通用的说法是：内容消费的App的增长有三驾马车，分别是：UG(用户增长)、推荐、广告。严格的来说，广告的那个位置上，变现团队都应该算。因为现在变现的方式有广告、会员、直播等等，形式变化比较多。不过现在最流行的变现手段应该还是广告，为避免歧义，我们行文的逻辑先按照只有广告这一种变现方式来。 广告收入主要的途径是通过这个公式实现的： 广告收入 = DAU × 用户平均使用时长 × 单位时长广告的曝光次数 × 广告点击率× 转化率 × 客单价 × 广告分成 这个公式各个变量名称应该还比较好理解，就不具体解释每一个变量什么意思了。我们来研究一下这个公式，分开来看。 DAU 首先最左侧的是用户规模DAU(Daily Active User，每日活跃用户)。DAU其实是一切产品收入规模的基础，类似的指标还有MAU(Monthly Active User，每月活跃用户)。所以大部分互联网向的App在公布自己的公司数据的时候，非常重要的一个指标就是自己的DAU/MAU数据，实在是因为DAU/MAU是一切收入的基础。 那么DAU具体是怎么形成的呢？我们具体来拆解一下。 当前用户数 = f(用户新增，用户留存) 当前用户的规模数，实际上是用户新增和用户留存的函数。当然还有其他的变量，比如回流用户数，就是一个用户来了，可能因为某些原因，这个用户流失了，过段时间他又来了。这种用户显然有别于一般意义上的新用户，通常被叫做回流用户。统计上一般把新用户的增长叫做”拉新”，回流用户再来叫做“拉活”，两者的策略某种程度上可以相同对待。 此外，影响当前用户规模数的还有App自身性质，比如打开的频率，比如抖音可能是天天打开，但工具类的App比如支付宝，是只有在使用的时候才会打开，这也会影响某一个时间点用户的DAU。 不过为了简单起见，在分析DAU时，我们还是分成用户新增用户和用户留存两个变量来分别进行拆解。 新增用户 用户的新增量受到哪些因素决定呢，其中比较重要的一个因素就是对外的广告和推广。 怎么样给自己的产品做广告其实背后是有学问的。常见的App广告的宣传方式一般有素材广告、品牌广告、预装等等。 我们首先来看一下素材广告。素材广告一般是指在其他App指定的广告位投放的广告。广告的内容可以是图文、视频、或者一个片段节选，这些被统称为素材。要制作一个好的素材广告，首先得知道在其他App的广告位是什么样的。比如抖音的广告位是竖屏的视频形式，而在豆瓣的广告位肯定就是图文类型。然后我们需要确定的素材本身，可以是一个代表性的内容(快来西瓜视频看虞书欣/孙燕姿的Vlog)、或者是请广告公司制作的片段。那应该选择什么样的素材呢？所以问题就转化成了，在众多可以选择的候选内容之中，选择哪些内容可以带来最多新用户？这就是一个比较明确的目标了，是一个可以建模或者进行统计分析的点。 接下来是品牌广告。品牌广告一般是指那些为了追求品牌的曝光而打的广告，一般会出现在一些公共场所，比如在楼梯间，公交站；或者是App的开屏、电视台的广告、综艺的冠名等等。选择在什么地方打广告，什么时候，打多久，这直接会决定受众是否看到这个广告，进而会决定因为这个广告产生的新增用户是否符合预期。品牌广告一个比较大的问题是不太好做归因：比如你在楼梯间看到了某一个品牌的广告，可能过了一会儿才想到了这个App决定下载尝试一下，这样新增用户就不再是因为品牌广告产生的了。所以品牌广告的统计分析更依赖一些经验。 还有一种用户增长的常见手段是预装。具体是指：用户购买到一个新的手机后，通常会发现在刚刚打开手机的时候就已经存在许多App。这意味着一个用户只要买了手机，就有可能成为这个App的潜在用户。这也是拉新用户的一个常见手段。这个手段在国内智能手机还没有完全普及的时候，伴随着大量的手机出货，可以用低廉的价格带来大量的新增。 这些渠道，或者说是方法：无论是素材的制作，品牌广告的投放，或者是手机预装，本身都是有成本的。而通过对外的广告带来的新增用户，如果最终在App内留存下来了，那从长期来看，这个用户大概率是可以为公司创造收入的(比如广告收入)，这个用户在长期在公司创造的价值，叫做LTV(Long Term Value)。这里面是有一套近似的估算方法，有点类似于保险精算的成本计算。 为了评估新增用户从收入成本的角度来说是否符合预期，人们定义了一个指标，叫做ROI。具体的计算方法是 ROI = 用户长期能创造的收入(LTV) / 用户新增的成本 我们就可以根据ROI的高低来衡量拉新的是否符合预期。 用户留存 接下来是用户留存。一般而言，用户留存受以下这几个因素的影响。 产品的基础体验：UI是否好看，产品逻辑是否符合逻辑，播放视频时候是否卡顿等等 内容推荐算法：推荐的商品和内容用户是否喜欢；是否有喜欢的作者；搜索的结果是否符合预期等等 产品自身的品牌 我们分开来说。用户来到一个产品。第一眼看到的是这个产品的UI，会尝试使用一两个基础的功能，这些功能基础体验上的好坏，会直接决定用户是否还会继续留在这个App(试想一下一个杂乱无章的UI上配着一个非常卡顿的页面，换谁都受不了)。产品的硬性指标，换句话说应该是用户的基础体验。所以我们需要UI、设计、客户端、服务端同学一起合作，给用户提供一个好的基础体验。 接下来用户会开始正式开始使用你这个App，会审视你这个App给他返回的内容是不是喜欢。这其实就是推荐算法开始发挥作用的地方了。所以我们需要一个好的推荐策略去承接新用户；还要保证，对于那些已经在App上有动作的用户，他的兴趣可以迅速收敛，让这个用户可以一直使用App，一直愉悦，停不下来，自然就留存了；对于那些已经使用了很久的老用户，我们要保证推荐的内容可以足够精准，帮助他筛选到自己想要的信息，保证他在这个App有足够的消费时长，同时可以留下来。 这时候用户可能会开始搜寻，这里是否有一些她自己之前听过名字的一些作者；同时可能会发现一些站内的特色——站内有一些其他平台没有的作者。从某种角度上来说，这些作者在站内首先得有，其次还能够分发出来。首先，保证作者在站内得有，对于有众多粉丝的大作者而言，需要作者运营同学的努力，通过某些手段和作者建立联系，个性化的满足这些作者的需求，同时帮助这些作者更好的在站内的环境下取得好的播放量和用户反馈。此外，运营的覆盖肯定不能覆盖所有的作者，推荐算法要能保证所有生产优质内容的作者可以推出来可以被用户看到，得到用户的反馈，同时，还得为小作者成长为大作者提供一个好的上升渠道。这一切都必须要得益于一个好的推荐算法分发的机制。 App品牌自身对用户的留存也很有影响。比方说，如果这时候市面上出现一个和抖音一模一样的App，就是不管从UI、内容、算法都一模一样，你是否还继续使用？大概率是不会的。因为你会觉得这个App太像抖音了，而你有抖音就够了。每一个品牌的背后，都是隐藏着消费者对这个品牌内在的认知。如果App的使用体验与消费者的认知相符，那消费者大概率会一直使用。如果消费者发现这个App的使用体验与认知不符，或者与自我设想中的比较类似，那可能大概率就不会留下。比如说打开今日头条App，你的预期是看下今天的天下新闻，但如果刷出来了很多搞笑段子，你可能大概率是不会留下的。 品牌的力量还体现在，一个成熟的品牌，是可以内化成为一个动词。用户在进行某种动作的时候，可能会第一时间就想到某个品牌。如果一个品牌可以做到这个程度，用户的留存一般都是会非常高的。比如搜索vs百度；发消息vs微信。其实就是品牌在消费者心目中的认知过于强烈了。 于是我们就拆解清楚了DAU的两个重要的影响因素，用户新增和留存。一般意义上，用户新增量的增长是有一些术可以去追求的，短期内如果想砸钱可能也可以搞定。但是如果要把一个App真正的做起来，还是要思考用户应该怎么样留存下来，这才是一个App长久的发展之道。 使用体验 接下来的两项我们合在一起说：用户平均使用时长 × 单位时长广告的曝光次数 用户的平均使用时长，很明显是一个推荐算法可以重点优化的指标。其实从经验看，用户的使用时长和用户的留存在很大程度上是正相关的——你觉得一个App好用了，你每天使用它的时长就会更长，同样的后面几天打开它的概率也就会越大。 单位时长广告的曝光次数，则是一个综合的产品决策了，因为这涉及到广告位的多少。广告位多了，用户不喜欢，用户的留存就会降低；广告位少了，收入不达标，不能最大化公司的收入。这其实是一个损失和收入trade-off的结果。因为现在用户普遍比较反感的点是在视频或者文章中段插广告，除非是视频作者或者文章作者的刻意为之。所以从这个角度说，同时这个指标和推荐还是有一点关系：推荐出太长的内容，是会影响广告收入的。(比较内容比较短的视频App想到了什么？没错，就是抖音。这也是这个产品本身很成功的地方。) 所以我们其实也已经拆解出了推荐算法在建模的时候需要注意的一些目标了： 最大的目标是保证用户留存，当然这个前提内容分发足够精准 尽可能让用户在App停留的时间更长，同时要注意控制，不能为了追求太长，而减少广告曝光。 需要有一个好的分发机制，帮助那些不是那么知名的作者可以成长起来。 广告收入 最后的几项： 广告点击率× 转化率 × 客单价 × 广告分成。 其实是广告算法主要考虑的问题，广告算法整体上和产品本身关联的就不是那么明显，更像是一个抽象好的技术问题。广告算法整体上我了解的并不多，这里只说一些我了解到的东西。 相对于推荐，广告是一个约束条件更多，优化目标更直接，更为技术的一个岗位。推荐与广告的核心诉求都是预估用户对某一个item是否满意。核心的目标都是做点击率预估。这也导致了推荐和广告整体的技术栈相似。此外，广告对于收入的贡献相对于推荐来说更加直接。推荐是通过优化点击率影响用户的使用时长或者留存来达到提升收入的目的，而广告优化点击率就可以直接影响最终的广告收入。所以，我个人觉得推荐更偏产品，广告更偏技术。 此外，个人总结一下有以下几点区别，具体是： 整体广告投放是有预算约束的(广告主的钱是有限制的) 广告主一般还会提一些要求，比如要投放到特定的人群上(比如投放到年轻女性上的化妆品广告) 广告主广告投放的周期相对来说比较短，比如双十一期间的广告可能只有几个小时 此外广告的计价体系也是千差万别，不同的计价体系下，需要关注的点也不一样 顺便说一句，每一个DAU能为App平均带来的收入，从统计意义上说是基本稳定的。有一个统计指标用来衡量这个值，叫做ARPU(Average Revenue Per User)，度量了一个App变现能力的高低。大家看上市公司财报可能会经常出现这个值。大家看某一个公司变现做的好不好，看这个值就可以了。 如今我们再回过头来看这样一个变现的公式，可以清楚的看到UG(用户新增)、推荐(用户留存)、广告(变现)在其中的重大作用。 广告收入 = DAU × 用户平均使用时长 × 单位时长广告的曝光次数 × 广告点击率× 转化率 × 客单价 × 广告分成 还有一点是，我们在学校里面，或者是学术领域关注的，NLP和CV的常见问题，在这个公式中其实并没有直接的体现出来，更多的是通过间接的方式和收入公式建立联系，比如作为NLP分类作为推荐模型的原始特征进行输入。这可能也是学校和工业界关注的问题有差别的重要原因。 除了广告变现之外，现在互联网公司也在尝试一些其他变现的方式：比如直播、会员等等，其中原理其实和广告是类似的。都是在一定用户群(DAU)的基础上，尽可能给用户找到他可能潜在喜欢的内容，留住他，然后再通过某种方式让他进行付费，转化成用户。大家可以按照类似的角度，思考一下。 比如现在大火的直播，大家可以思考一下直播应该从什么样的角度去建模，怎么样可以留住用户，而传统的信息流的推荐有什么异同。又怎么样可以鼓励用户多消费，应该采用什么样的策略。如果能够给公司创造更大的价值，个人的发展的渠道和路径自然也是一路畅通。 成本 之前我们都一直在谈收入，我们再来谈一下成本。其实从一个公司的角度出发，凡是不能创造收入的成本，对于公司来说其实都是属于无用的成本，需要被干掉。 除了公司正常的人力成本之外，在对收入至关重要的三驾马车(UG、推荐、广告)中，UG相关的成本我们已经介绍过了，可以通过ROI进行度量策略的好坏。 推荐和广告这个方向，目前最大的成本肯定还是机器成本。所以现在一个研究的重要方向是，怎么样可以在模型效果保持不变的情况下，尽可能的减少机器成本。比较关键的就是进行模型的精简；以及对运算本身进行更进一步的优化。而后者的巨大需求，也造就了现在搞AI基础设施的工程师极度紧俏的——假设你可以优化一个分布式计算CPU消耗仅为原来的40%，那就相当于是公司的机器成本可以变成原来的40%呀。 总结 在商言商，如果想在公司取得更好的位置和级别，非常重要的一点是要为公司创造出更大的价值。如果想为公司创造出更大价值，就需要从全局的角度思考，公司当前的价值是由什么构成的，瓶颈在什么地方，我们能为这个瓶颈又能有什么样的贡献呢。 作者: 峰池，一个爱读书的算法工程师            最近更新： 2021-03-09 06:44:53 "},"chap05/1-book_recommend.html":{"url":"chap05/1-book_recommend.html","title":"5-1 推荐资料","keywords":"","body":"5-1 推荐资料 汇总一下本书中提到的一些重要的参考资料。 机器学习算法 《统计学习方法》 李航老师的经典著作，三言两语把传统机器学习很精巧的串起来了。第二版在之前第一版的基础上，加了很多无监督学习的知识点。强烈推荐大家对机器学习感兴趣的同学把这本书上的每一个方法都自己推一遍。现在传统机器学习方法可能从效果上没有深度学习网络好，但是一些思想以及对机器学习的理解对做模型是很有启发的。 《神经网络与深度学习》 这是我个人认为国内最好的深度学习教材，比花书《深度学习》要好很多，可能是因为是中国人自己写的。清晰的数学语言描述方法的核心原理，兼具准确与深度，重要的是非常新！基本18年之前的主要方法和论文都有涉及到！我个人强烈推荐。 这本书网上有免费开源的电子版PDF，亲测在iPad上阅读体验非常赞！ https://nndl.github.io/ 《百面机器学习》、《百面深度学习》 这是两本书，以面试题的形式，展开讲了很多机器学习和深度学习的算法细节。即可以当做算法工程师面试时候的题库，也可以当做自己查漏补缺的知识点。 《深度学习推荐系统》 如果大家对推荐系统感兴趣的话，这本书可以说是深度学习时代讲推荐系统最好的一本书。对深度学习推荐系统的模型结构，embedding的应用，以及一些工程架构讲的都非常清楚。 代码能力 《算法导论》、《数据结构与算法分析》 不多说，计算机算法或者说数据结构经典教科书。不过，我个人觉得其实《算法导论》试图讲明白的东西太多了，反而觉得读起来有点不那么清爽；相比之下《数据结构与算法分析》就简单直接得多，直接上代码。 反正数据结构学到最后都是要刷leetcode题目的，刷就对了。 《重构》 这是一本非常细致的讲解如何进行代码重构的书，在。但我觉得更核心的是如何定义一些需要重构的部分，即书中所谓发现代码的bad smell。一个好的编码习惯会帮助你写出更好的可维护的代码。 《设计模式》、《Head First 设计模式》 工作中的代码量可能随随便便一个项目就是数万甚至数十万级别的代码量，怎么样维护这么大量的代码，就依赖设计模式方面的知识。上面一本是经典教材，但是讲的略显晦涩(一看张一鸣只打了8分)，适合当工具书。下面一本图文并茂，适合当初学者入门书。 比较重要的，应该就这些了。书很多，更主要的还是需要自己看，这样才能真正帮到自己，让自己有所成长。 作者: 峰池，一个爱读书的算法工程师            最近更新： 2021-03-09 06:44:53 "}}